<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mongodb合集</title>
      <link href="/2020/04/16/Mongodb%E5%90%88%E9%9B%86/"/>
      <url>/2020/04/16/Mongodb%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a><strong>Linux安装</strong></h4><p>wget <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-4.0.1.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-4.0.1.tgz</a></p><p>mkdir -p mongodb-3.0.6</p><p>tar -zxvf mongodb-linux-x86_64-3.0.6.tgz -C /usr/local/mongodb</p><p>mv mongodb-linux-x86_64-3.0.6/* /usr/local/mongodb-3.0.6</p><p>mkdir data</p><p>touch logs</p><p>vi mongo.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#bind_ip_all = true                 # 任何机器可以连接</span><br><span class="line">bing_ip = 127.0.0.1               # 本机可以访问</span><br><span class="line">port = 27017                        # 实例运行在27017端口（默认）</span><br><span class="line">dbpath = /usr/local/mongodb-3.0.6/data      # 数据文件夹存放地址（db要预先创建）</span><br><span class="line">logpath = /usr/local/mongodb-3.0.6/logs/27017.log  # 日志文件地址</span><br><span class="line">logappend = false                   # 启动时 添加还是重写日志文件</span><br><span class="line">fork = true                         # 是否后台运行</span><br><span class="line">auth = false                         # 开启校验用户</span><br></pre></td></tr></table></figure><p>添加环境变量<br>vi /etc/profile<br>增加一行  export PATH=/usr/local/mongodb-4.2.5/bin<br>使其生效 echo $PATH</p><p>启动命令<br>cd /usr/local/mongodb-4.2.5<br>mongod -f mongo.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">添加管理员账号</span><br><span class="line">mongo</span><br><span class="line">use admin</span><br><span class="line">db.system.users.find();</span><br><span class="line"></span><br><span class="line">设置用户密码</span><br><span class="line">use admin</span><br><span class="line">db.createUser(&#123;user: &apos;root&apos;, pwd: , roles: [&apos;root&apos;]&#125;)</span><br><span class="line"></span><br><span class="line">登陆验证密码</span><br><span class="line">db.auth(&apos;root&apos;,)</span><br><span class="line"></span><br><span class="line">修改密码</span><br><span class="line">db.changeUserPassword(&apos;root&apos;,);</span><br><span class="line"></span><br><span class="line">show dbs</span><br><span class="line">use gis</span><br><span class="line">设置数据库权限</span><br><span class="line">db.createUser(&#123;user:&apos;gis&apos;,pwd:,roles: [&#123;role:&apos;readWrite&apos;,db:&apos;gis&apos;&#125;]&#125;)</span><br><span class="line">登陆验证密码</span><br><span class="line">db.auth(&apos;gis&apos;,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">建二维索引</span><br><span class="line">db.shopLocation.createIndex(&#123;location: &quot;2dsphere&quot;&#125;,&#123;name:&quot;geoNear query&quot;&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th>Keyword</th><th>Sample</th><th>Logical result</th></tr></thead><tbody><tr><td>After</td><td>findByBirthdateAfter(Date date)</td><td>{“birthdate” : {“$gt” : date}}</td></tr><tr><td>GreaterThan</td><td>findByAgeGreaterThan(int age)</td><td>{“age” : {“$gt” : age}}</td></tr><tr><td>GreaterThanEqual</td><td>findByAgeGreaterThanEqual(int age)</td><td>{“age” : {“$gte” : age}}</td></tr><tr><td>Before</td><td>findByBirthdateBefore(Date date)</td><td>{“birthdate” : {“$lt” : date}}</td></tr><tr><td>LessThan</td><td>findByAgeLessThan(int age)</td><td>{“age” : {“$lt” : age}}</td></tr><tr><td>LessThanEqual</td><td>findByAgeLessThanEqual(int age)</td><td>{“age” : {“$lte” : age}}</td></tr><tr><td>Between</td><td>findByAgeBetween(int from, int to)</td><td>{“age” : {“$gt” : from, “$lt” : to}}</td></tr><tr><td>In</td><td>findByAgeIn(Collection ages)</td><td>{“age” : {“$in” : [ages…​]}}</td></tr><tr><td>NotIn</td><td>findByAgeNotIn(Collection ages)</td><td>{“age” : {“$nin” : [ages…​]}}</td></tr><tr><td>IsNotNull, NotNull</td><td>findByFirstnameNotNull()</td><td>{“firstname” : {“$ne” : null}}</td></tr><tr><td>IsNull, Null</td><td>findByFirstnameNull()</td><td>{“firstname” : null}</td></tr><tr><td>Like, StartingWith, EndingWith</td><td>findByFirstnameLike(String name)</td><td>{“firstname” : name} (name as regex)</td></tr><tr><td>NotLike, IsNotLike</td><td>findByFirstnameNotLike(String name)</td><td>{“firstname” : { “$not” : name }} (name as regex)</td></tr><tr><td>Containing on String</td><td>findByFirstnameContaining(String name)</td><td>{“firstname” : name} (name as regex)</td></tr><tr><td>NotContaining on String</td><td>findByFirstnameNotContaining(String name)</td><td>{“firstname” : { “$not” : name}} (name as regex)</td></tr><tr><td>Containing on Collection</td><td>findByAddressesContaining(Address address)</td><td>{“addresses” : { “$in” : address}}</td></tr><tr><td>NotContaining on Collection</td><td>findByAddressesNotContaining(Address address)</td><td>{“addresses” : { “$not” : { “$in” : address}}}</td></tr><tr><td>Regex</td><td>findByFirstnameRegex(String firstname)</td><td>{“firstname” : {“$regex” : firstname }}</td></tr><tr><td>(No keyword)</td><td>findByFirstname(String name)</td><td>{“firstname” : name}</td></tr><tr><td>Not</td><td>findByFirstnameNot(String name)</td><td>{“firstname” : {“$ne” : name}}</td></tr><tr><td>Near</td><td>findByLocationNear(Point point)</td><td>{“location” : {“$near” : [x,y]}}</td></tr><tr><td>Near</td><td>findByLocationNear(Point point, Distance max)</td><td>{“location” : {“$near” : [x,y], “$maxDistance” : max}}</td></tr><tr><td>Near</td><td>findByLocationNear(Point point, Distance min, Distance max)</td><td>{“location” : {“$near” : [x,y], “$minDistance” : min, “$maxDistance” : max}}</td></tr><tr><td>Within</td><td>findByLocationWithin(Circle circle)</td><td>{“location” : {“$geoWithin” : {“$center” : [ [x, y], distance]}}}</td></tr><tr><td>Within</td><td>findByLocationWithin(Box box)</td><td>{“location” : {“$geoWithin” : {“$box” : [ [x1, y1], x2, y2]}}}</td></tr><tr><td>IsTrue, True</td><td>findByActiveIsTrue()</td><td>{“active” : true}</td></tr><tr><td>IsFalse, False</td><td>findByActiveIsFalse()</td><td>{“active” : false}</td></tr><tr><td>Exists</td><td>findByLocationExists(boolean exists)</td><td>{“location” : {“$exists” : exists }}</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软件合集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器搭建</title>
      <link href="/2020/03/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="登陆免密"><a href="#登陆免密" class="headerlink" title="登陆免密"></a><strong>登陆免密</strong></h4><p>生成本地快捷指令：<br>vi /usr/local/etc/self_command/alias.sh<br>source /usr/local/etc/self_command/alias.sh<br>查看本地公钥：cat ~/.ssh/id_rsa.pub<br>没有则生成公钥：ssh-keygen -t rsa<br>将公钥拷贝粘贴到远程服务器：vi .ssh/authorized_keys<br>设置远程服务器权限 chmod 600 /root/.ssh/authorized_keys<br>*<em>注意：拷贝粘贴可能会丢失 ssh的s *</em><br>部分软件在 projectinit 目录下<br>scp local_file remote_username@remote_ip:remote_folder</p><h4 id="安装lz-rz"><a href="#安装lz-rz" class="headerlink" title="安装lz rz"></a><strong>安装lz rz</strong></h4><p>yum -y install lrzsz</p><h4 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a><strong>安装jdk</strong></h4><p>查看版本  java -version<br>下载   <a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</a></p><p>mkdir -p /usr/local/java<br>tar -vzxf jdk-8u241-linux-x64.tar.gz -C /usr/local/java/<br>vim /etc/profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_241</span><br><span class="line">export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>source /etc/profile<br>java -version</p><h4 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a><strong>安装maven</strong></h4><p>下载  <a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a><br>mkdir -p /usr/local/maven<br>tar -vzxf apache-maven-3.6.3-bin.tar.gz -C /usr/local/maven/<br>vim /etc/profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/usr/local/maven/apache-maven-3.6.3</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><p>source /etc/profile<br>mvn -v</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a><strong>安装git</strong></h4><p>yum -y install git</p><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a><strong>安装nginx</strong></h4><p>下载 wget <a href="http://nginx.org/download/nginx-1.9.9.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.9.9.tar.gz</a><br>mkdir -p /usr/local/nginx<br>tar -vzxf nginx-1.9.9.tar.gz -C /usr/local/nginx/</p><p>yum -y install gcc gcc-c++ autoconf automake make<br>yum -y install openssl openssl-devel<br>./configure –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_ssl_module –with-file-aio –with-http_realip_module<br>make<br>make install   #会将文件自动拷贝到nginx目录</p><p>*<em>看443端口是否打开 nc -v 118.25.16.76 443<br>查443端口有没有监听 netstat -atnp -A inet | grep -i listen | uniq -c<br>没监听的要看vhosts目录对不对<br>*</em></p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a><strong>安装mysql</strong></h4><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><strong>初始化项目</strong></h4><p>mkdir -p /usr/local/superad/superad-server<br>cd /usr/local/superad/superad-server<br>上传sh脚本<br>执行build  或者从别处拷贝包过来<br>scp superad-server-1.0.jar <a href="mailto:root@152.136.234.233" target="_blank" rel="noopener">root@152.136.234.233</a>:/usr/local/superad/superad-server</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见工具说明</title>
      <link href="/2020/03/05/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/03/05/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h4 id="pinpoint"><a href="#pinpoint" class="headerlink" title="pinpoint"></a><strong>pinpoint</strong></h4><p>全链路追踪工具，其原理是基于字节码增强技术，Agent探针部署在应用，在class加载到jvm之前，在方法调用的前后，加上相应的逻辑，javaAgent的底层机制主要依赖JVMTI ，JVMTI全称JVM Tool Interface，是JVM暴露出来的一些供用户扩展的接口集合。JVMTI是基于事件驱动的，JVM每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者扩展自己的逻辑。但JVMTI都是一些接口合集，需要有接口的实现，这就用到了java的instrument，可以理解instrument是JVMTI的一种实现，为JVM提供外挂支持</p><ul><li>ASM 针对需要手动修改字节码的需求，可以直接在编译期直接生产.class文件，也可以在jvm加载类之前修改类行为</li><li>javaassist 源代码层次操作字节码框架，直接代码去操作字节码，主要是ClassPool、CtClass、CtField、CtMethod</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2020/03/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/03/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a><strong>1.面向对象和面向过程的区别</strong></h4><ul><li>面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</li><li>面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</span><br><span class="line">而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-Java语言有哪些特点"><a href="#2-Java语言有哪些特点" class="headerlink" title="2.Java语言有哪些特点"></a><strong>2.Java语言有哪些特点</strong></h4><ul><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修正：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-关于JVM-JDK和JRE"><a href="#3-关于JVM-JDK和JRE" class="headerlink" title="3.关于JVM JDK和JRE"></a><strong>3.关于JVM JDK和JRE</strong></h4><ul><li>JVM<br>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<h4 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h4>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。<h4 id="Java-程序从源代码到运行一般有下面-3-步："><a href="#Java-程序从源代码到运行一般有下面-3-步：" class="headerlink" title="Java 程序从源代码到运行一般有下面 3 步："></a>Java 程序从源代码到运行一般有下面 3 步：</h4><img src="/images/pasted-67.png" alt="upload successful"><br>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li><li>JDK和JRE<br>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。<br>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。<br>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</li></ul><h4 id="4-Oracle-JDK和Open-JDK对比"><a href="#4-Oracle-JDK和Open-JDK对比" class="headerlink" title="4.Oracle JDK和Open JDK对比"></a><strong>4.Oracle JDK和Open JDK对比</strong></h4><ul><li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。</li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ul><h4 id="5-Java和C-的区别"><a href="#5-Java和C-的区别" class="headerlink" title="5.Java和C++的区别"></a><strong>5.Java和C++的区别</strong></h4><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li></ul><h4 id="6-什么是Java程序的主类，应用程序和小程序的主类有何不同"><a href="#6-什么是Java程序的主类，应用程序和小程序的主类有何不同" class="headerlink" title="6.什么是Java程序的主类，应用程序和小程序的主类有何不同"></a><strong>6.什么是Java程序的主类，应用程序和小程序的主类有何不同</strong></h4><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p><h4 id="7-Java应用程序和小程序有何区别"><a href="#7-Java应用程序和小程序有何区别" class="headerlink" title="7.Java应用程序和小程序有何区别"></a><strong>7.Java应用程序和小程序有何区别</strong></h4><p>简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p><h4 id="8-字符型常量和字符串常量有何区别"><a href="#8-字符型常量和字符串常量有何区别" class="headerlink" title="8.字符型常量和字符串常量有何区别"></a><strong>8.字符型常量和字符串常量有何区别</strong></h4><ul><li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)<br><img src="/images/pasted-70.png" alt="upload successful"></li></ul><h4 id="9-构造器Constructor是否可被override"><a href="#9-构造器Constructor是否可被override" class="headerlink" title="9.构造器Constructor是否可被override"></a><strong>9.构造器Constructor是否可被override</strong></h4><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h4 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10.重载和重写的区别"></a><strong>10.重载和重写的区别</strong></h4><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。<br>下面是《Java 核心技术》对重载这个概念的介绍：<br><img src="/images/pasted-71.png" alt="upload successful"></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。</p><h4 id="11-Java-面向对象编程三大特性-封装-继承-多态"><a href="#11-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="11.Java 面向对象编程三大特性: 封装 继承 多态"></a><strong>11.Java 面向对象编程三大特性: 封装 继承 多态</strong></h4><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。<br>关于继承如下 3 点请记住：</p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h4 id="12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="12.String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a><strong>12.String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</strong></h4><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。<br>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder.java</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The value is used for character storage.</span><br><span class="line">     */</span><br><span class="line">    char[] value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The count is the number of characters used.</span><br><span class="line">     */</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(int capacity) &#123;</span><br><span class="line">        value = new char[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h4 id="对于三者使用的总结"><a href="#对于三者使用的总结" class="headerlink" title="对于三者使用的总结"></a>对于三者使用的总结</h4><ul><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ul><h4 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13.自动装箱与拆箱"></a><strong>13.自动装箱与拆箱</strong></h4><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><h4 id="14-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="14.在一个静态方法内调用一个非静态成员为什么是非法的?"></a><strong>14.在一个静态方法内调用一个非静态成员为什么是非法的?</strong></h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。<br>在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。</p><h4 id="15-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15.在 Java 中定义一个不做事且没有参数的构造方法的作用"></a><strong>15.在 Java 中定义一个不做事且没有参数的构造方法的作用</strong></h4><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="16-import-java-和-javax-有什么区别？"><a href="#16-import-java-和-javax-有什么区别？" class="headerlink" title="16.import java 和 javax 有什么区别？"></a><strong>16.import java 和 javax 有什么区别？</strong></h4><p>Java和Javax本质上是与Java编程语言的上下文一起使用的包。提出java包的命令是import java，而启动javax包的命令是import javax。例如：import java.util.<em>; 或者导入javax.util.</em>;<br>原来，作为标准API的一部分的所有内容都是java包的一部分，而不是标准API一部分的所有内容都是在包名javax下发布的。因此，API所必需的包是java，而javax包含API的扩展名。甚至可以说javax，只是一个带有x的java，代表了扩展。<br>随着时间的推移，作为javax发布的扩展成为Java API的组成部分。但是，将扩展从javax包移动到java包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定javax包将成为标准API的一部分。<br>所以，实际上java和javax没有区别。这都是一个名字。</p><h4 id="17-接口和抽象类的区别"><a href="#17-接口和抽象类的区别" class="headerlink" title="17.接口和抽象类的区别"></a><strong>17.接口和抽象类的区别</strong></h4><ul><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li><li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">关于抽象类</span><br><span class="line">JDK 1.8以前，抽象类的方法默认访问权限为protected</span><br><span class="line">JDK 1.8时，抽象类的方法默认访问权限变为default</span><br><span class="line">关于接口</span><br><span class="line">JDK 1.8以前，接口中的方法必须是public的</span><br><span class="line">JDK 1.8时，接口中的方法可以是public的，也可以是default的</span><br><span class="line">JDK 1.9时，接口中的方法可以是private的</span><br><span class="line">在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</span><br><span class="line">jdk9 的接口被允许定义私有方法 。</span><br></pre></td></tr></table></figure></li></ul><p>总结一下 jdk7~jdk9 Java 中接口概念的变化</p><ul><li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li><li>jdk8 的时候接口可以有默认方法和静态方法功能。</li><li>Jdk9 在接口中引入了私有方法和私有静态方法。</li></ul><h4 id="18-成员变量和局部变量的区别"><a href="#18-成员变量和局部变量的区别" class="headerlink" title="18.成员变量和局部变量的区别"></a><strong>18.成员变量和局部变量的区别</strong></h4><ul><li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h4 id="19-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#19-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="19.创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a><strong>19.创建一个对象用什么运算符?对象实体与对象引用有何不同?</strong></h4><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h4 id="20-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#20-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="20.什么是方法的返回值?返回值在类的方法里的作用是什么?"></a><strong>20.什么是方法的返回值?返回值在类的方法里的作用是什么?</strong></h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h4 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="21.一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a><strong>21.一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</strong></h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h4 id="22-构造方法有哪些特性"><a href="#22-构造方法有哪些特性" class="headerlink" title="22.构造方法有哪些特性"></a><strong>22.构造方法有哪些特性</strong></h4><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><h4 id="23-静态方法和实例方法有何不同"><a href="#23-静态方法和实例方法有何不同" class="headerlink" title="23.静态方法和实例方法有何不同"></a><strong>23.静态方法和实例方法有何不同</strong></h4><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ul><h4 id="24-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#24-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="24.对象的相等与指向他们的引用相等,两者有什么不同?"></a><strong>24.对象的相等与指向他们的引用相等,两者有什么不同?</strong></h4><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h4 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="25.在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a><strong>25.在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</strong></h4><p>帮助子类做初始化工作。</p><h4 id="26-与equals"><a href="#26-与equals" class="headerlink" title="26.==与equals()"></a><strong>26.==与equals()</strong></h4><ul><li>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</li><li>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<br>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">        String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">        String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">        if (aa == bb) // true</span><br><span class="line">            System.out.println(&quot;aa==bb&quot;);</span><br><span class="line">        if (a == b) // false，非同一对象</span><br><span class="line">            System.out.println(&quot;a==b&quot;);</span><br><span class="line">        if (a.equals(b)) // true</span><br><span class="line">            System.out.println(&quot;aEQb&quot;);</span><br><span class="line">        if (42 == 42.0) &#123; // true</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。<br>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。<h4 id="27-hashCode-与equals"><a href="#27-hashCode-与equals" class="headerlink" title="27.hashCode()与equals()"></a><strong>27.hashCode()与equals()</strong></h4><h4 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h4>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。<br>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）<h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。<br>通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。<h4 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h4>如果两个对象相等，则 hashcode 一定也是相同的<br>两个对象相等,对两个对象分别调用 equals 方法都返回 true<br>两个对象有相同的 hashcode 值，它们也不一定是相等的<br>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><h4 id="28-为什么java中只有值传递"><a href="#28-为什么java中只有值传递" class="headerlink" title="28.为什么java中只有值传递"></a><strong>28.为什么java中只有值传递</strong></h4><p>详见收藏</p><h4 id="29-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#29-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="29.简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a><strong>29.简述线程、程序、进程的基本概念。以及他们之间关系是什么?</strong></h4><ul><li>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li><li>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</li><li>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li></ul><h4 id="30-线程有哪些基本状态"><a href="#30-线程有哪些基本状态" class="headerlink" title="30.线程有哪些基本状态?"></a><strong>30.线程有哪些基本状态?</strong></h4><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）<br><img src="/images/pasted-72.png" alt="upload successful"><br>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）<br><img src="/images/pasted-73.png" alt="upload successful"><br>由上图可以看出：<br>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。<br>当线程执行 wait()方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</p><h4 id="31-关于final关键字"><a href="#31-关于final关键字" class="headerlink" title="31.关于final关键字"></a><strong>31.关于final关键字</strong></h4><p>final 关键字主要用在三个地方：变量、方法、类。</p><ul><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li><li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li></ul><h4 id="32-Java中的异常处理"><a href="#32-Java中的异常处理" class="headerlink" title="32.Java中的异常处理"></a><strong>32.Java中的异常处理</strong></h4><h4 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h4><p><img src="/images/pasted-74.png" alt="upload successful"><br>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。<br>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。<br>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。<br>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。<br>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</p><h4 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h4><ul><li><p>public string getMessage():返回异常发生时的简要描述</p></li><li><p>public string toString():返回异常发生时的详细信息</p></li><li><p>public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同</p></li><li><p>public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息</p><h4 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h4></li><li><p>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</p></li><li><p>catch 块： 用于处理 try 捕获到的异常。</p></li><li><p>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<br>在以下 4 种特殊情况下，finally 块不会被执行：</p></li><li><p>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</p></li><li><p>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</p></li><li><p>程序所在的线程死亡。</p></li><li><p>关闭 CPU。<br><img src="/images/pasted-76.png" alt="upload successful"><br><img src="/images/pasted-77.png" alt="upload successful"><br><img src="/images/pasted-78.png" alt="upload successful"><br><img src="/images/pasted-79.png" alt="upload successful"><br><img src="/images/pasted-80.png" alt="upload successful"><br><img src="/images/pasted-81.png" alt="upload successful"><br><img src="/images/pasted-82.png" alt="upload successful"><br><img src="/images/pasted-83.png" alt="upload successful"><br><img src="/images/pasted-84.png" alt="upload successful"><br>当程序执行try块，catch块时遇到return语句或者throw语句，这两个语句都会导致该方法立即结束，所以系统并不会立即执行这两个语句，而是 去寻找该异常处理流程中的finally块，如果没有finally块，程序立即执行return语句或者throw语句，方法终止。如果有 finally块，系统立即开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的 return或throw语句，如果finally块里也使用了return或throw等导致方法终止的语句，则finally块已经终止了方法，不用再跳回去执行try块、catch块里的任何代码了。</p></li></ul><h4 id="33-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#33-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="33.Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><em>33.Java 序列化中如果有些字段不想进行序列化，怎么办？</em></h4><p>对于不想进行序列化的变量，使用 transient 关键字修饰。<br>transient 关键字的作用是：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p><h4 id="34-为什么java对象需要序列化，实现方式？"><a href="#34-为什么java对象需要序列化，实现方式？" class="headerlink" title="34.为什么java对象需要序列化，实现方式？"></a><em>34.为什么java对象需要序列化，实现方式？</em></h4>]]></content>
      
      
      <categories>
          
          <category> LSM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2020/02/27/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/02/27/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a><strong>TCC</strong></h4><p>相关开源框架：ByteTCC、Himly、TCC-transaction</p><ul><li>Try 这个阶段是去预占，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据，如：修改订单状态支付中，冻结一部分库存</li><li>Confirm  </li><li>Cancel</li></ul><h4 id="示例消息数据表"><a href="#示例消息数据表" class="headerlink" title="示例消息数据表"></a><strong>示例消息数据表</strong></h4><p>名称|    数据类型 |允许空|    默认值|    属性|    释义<br>-|-|-<br>uuid|    varchar(50)|    No|    —    |unique    |UUID<br>version|    int(11)    |No|    0|    —    |版本号<br>editer|    varchar(100)|    Yes|    NULL|    —|    修改者<br>creater|    varchar(100)|    Yes|    NULL|    —|    创建者<br>edit_time|    datetime|    Yes|    0000-00-00 00:00:00|    —|    最后修改时间<br>create_time|    datetime|    No|    0000-00-00 00:00:00    |—    |创建时间<br>msg_id|    varchar(50)    |No|    —|    —|    消息ID<br>msg_body|    longtext|    No|    —|    —    |消息内容<br>msg_date_type|    varchar(50)|    Yes|    —    |—|    消息数据类型<br>consumer_queue|    varchar(100)|    No|    —    |—|    消费队列<br>send_times|    int(6)|    No|    0|    —|    消息重发次数<br>is_dead|    varchar(20)|    No|    —|    —    |是否死亡<br>status|    varchar(20)|    No|    —|    —|    状态<br>remark|    varchar(200)|    Yes|    —|    —    |备注<br>field0|    varchar(200)|    Yes|    —|    —|    扩展字段0<br>field1|    varchar(200)|    Yes|    —|    —|    扩展字段1<br>field2|    varchar(200)|    Yes|    —|    —|    扩展字段2</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2020/02/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2020/02/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="MQ如何保证消息不丢失"><a href="#MQ如何保证消息不丢失" class="headerlink" title="MQ如何保证消息不丢失"></a><strong>MQ如何保证消息不丢失</strong></h4><p>首先mq丢数据分三种情况</p><p>1.生产者网mq写数据时<br>2.mq丢数据（如宕机）<br>3.消费者丢数据（consumer宕机）</p><p>先说rabitmq：<br>1）生产者丢数据<br>　　1.rabitmq提供事物功能（百分百不会丢数据）但是会降低吞吐量（同步事物会阻塞）<br>　　2.开启confirm模式，异步ack机制（失败消息重发）、<br>2）rabbitmq弄丢了数据<br>　　1.开启rabbitmq的持久化（除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小）<br>　　2.持久化配合confirm模式，只有当所有的消息持久化到硬盘之后才返回ack，可以保证百分百不会丢失数据<br>3）消费端弄丢了数据<br>　　1.rabbitmq提供的ack机制（但是要关闭rabitmq的自动ack机制，当consumer处理完消息之后手动ack）</p><p>再说kafka：<br>1）消费端弄丢了数据<br>　　1.关闭自动提交offset，在处理完之后自己手动提交offset，就可以保证数据不会丢。但是此时确实还是会重复消费（幂等性）<br>2）kafka弄丢了数据<br>　　1.主从切换的时候丢数据。解决办法时调参数，当produce发送消息给kafaka失败是就无限重试，只有当消息全部到达rplicate副本时才返回ack.</p><h4 id="MQ比较"><a href="#MQ比较" class="headerlink" title="MQ比较"></a><strong>MQ比较</strong></h4><p><a href="https://cloud.tencent.com/developer/article/1442105" target="_blank" rel="noopener">3种主流的MQ对比</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="/2020/02/26/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/02/26/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h4><p>序列化就是将内存中的对象转换为字节序列，方便持久化到磁盘或者网络传输，对象序列化可分为两步：</p><ul><li><p>将对象转换成字节数组</p></li><li><p>将字节数组存储到磁盘<br>ObjectOutputStream：对象输出流，它的writeObject方法将对象序列化，把得到的字节序列写到一个目标输出流中<br>ObjectInputStream：对象输入流，它的readObject方法读取字节序列，将对象反序列化成对象</p></li><li><p>静态变量是不可序列化的</p></li><li><p>被transient修饰的不可序列化</p></li></ul><h4 id="实现Serializable接口"><a href="#实现Serializable接口" class="headerlink" title="实现Serializable接口"></a><strong>实现Serializable接口</strong></h4><p>当ObjectOutputStream按照默认方式反序列化时，具有如下特点：</p><ul><li>如果在内存中对象所属的类还没有被加载，那么会先加载并初始化这个类。如果在classpath中不存在相应的类文件，那么会抛出ClassNotFoundException；</li><li>在反序列化时不会调用类的任何构造方法</li><li>serialVersionUID标识的是类序列化版本，当jvm反序列化传过来的类时，会把传过来sid与本地的sid进行比较，如果不一致会报错InvalidCastException，显式地定义serialVersionUID有两种用途：<ul><li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li><li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID；</li></ul></li></ul><h4 id="实现Externalizable接口"><a href="#实现Externalizable接口" class="headerlink" title="实现Externalizable接口"></a><strong>实现Externalizable接口</strong></h4><p>Externalizable继承自Serializable，表示这个类的序列化和反序列化都由自己实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void writeExternal(ObjectOutput out) throws IOException</span><br><span class="line">public void readExternal(ObjectInput in) throws IOException , ClassNotFoundException</span><br></pre></td></tr></table></figure><h4 id="序列化框架"><a href="#序列化框架" class="headerlink" title="序列化框架"></a><strong>序列化框架</strong></h4><p>JDK<br>FastJson<br>Hessian<br>Protostuff<br>参考：<a href="https://www.cnblogs.com/lgjlife/p/10731099.html" target="_blank" rel="noopener">序列化框架比较</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSO</title>
      <link href="/2020/02/25/SSO/"/>
      <url>/2020/02/25/SSO/</url>
      
        <content type="html"><![CDATA[<h4 id="三种解决方案"><a href="#三种解决方案" class="headerlink" title="三种解决方案"></a><strong>三种解决方案</strong></h4><ul><li>同一公司,同父域下的单点登录解决方案：如map.baidu.com,image.baidu.com，这种可以基于cookie实现，如 JWT</li><li>同一公司,不同域下的单点登录解决方案：如<a href="http://www.taobao.com，www.tmall.com，这种可以基于中央认证服务器实现，如" target="_blank" rel="noopener">www.taobao.com，www.tmall.com，这种可以基于中央认证服务器实现，如</a> CAS</li><li>不同公司之间,不同域下的 第三方登录功能实现，如支持qq登录，微博登录，这种可基于OAuth2.0实现</li></ul><h4 id="基于JWT实现"><a href="#基于JWT实现" class="headerlink" title="基于JWT实现"></a><strong>基于JWT实现</strong></h4><p>JWT即JSON Web Token，实际是信息加密的一种方式<br>原理：服务端生成一个token，客户端每次调用都需要携带token，但是这个token并不需要服务端存储，它是按照一定的算法，将失效时间等信息，通过加密算法存储到token中，每次校验都是自校验</p><ul><li>优点：不占服务器存储资源，集成简单</li><li>缺点：没办法失效，必须要到指定时间才会失效</li></ul><p>jwt的结构</p><ul><li>header 由typ和alg组成，typ标识token是一个jwt的，alg标识签名和摘要算法</li><li>payload 有标准声明、公共声明、私有声明，比如用来传递用户名、密码、是否管理员</li><li>signature 则是有前面的 header和payload中间加一点，再进行alg指定的算法处理</li></ul><p>payload标准中注册的声明 (建议但不强制使用) ：<br>iss: jwt签发者<br>sub: 面向的用户(jwt所面向的用户)<br>aud: 接收jwt的一方<br>exp: 过期时间戳(jwt的过期时间，这个过期时间必须要大于签发时间)<br>nbf: 定义在什么时间之前，该jwt都是不可用的.<br>iat: jwt的签发时间<br>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p><p>公共的声明 ：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><p>私有的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><img src=/images/pasted-60.png width=60% style="border:1px solid orange" alt=JWT /><h4 id="基于CAS实现"><a href="#基于CAS实现" class="headerlink" title="基于CAS实现"></a><strong>基于CAS实现</strong></h4><p>主要步骤分为:  </p><ul><li>1:用户请求CAS Client的某一个网站,或者直接请求CAS Server登录页面;</li><li>2:用户到CAS Server的登录页面进行验证,验证成功,CAS Server返回ticket到客户端; </li><li>3:客户端再次请求CAS Client资源, CAS Client携带ticket到CAS Server认证,成功则继续访问;<br>实现步骤: </li><li>1: 搭建CAS Server端,可使用CAS的框架实现;可自定义登录页面;实现其内部接口即可; </li><li>2: 搭建CAS Client端,就是公司不同的服务器系统,携带秘钥即可;<img src=/images/pasted-61.png width=60% style="border:1px solid orange" alt=CAS /></li></ul><h4 id="基于OAuth2-0实现"><a href="#基于OAuth2-0实现" class="headerlink" title="基于OAuth2.0实现"></a><strong>基于OAuth2.0实现</strong></h4><p>是开放授权的一个标准，允许用户授权B应用在不提供用户名和密码的情况下，去获取用户在A应用上的某些特定资源<br>四种授权模式</p><ul><li>简单模式：没有授权码，直接获取token，容易被拦截泄露，适用于公开单页浏览</li><li>用户名密码模式：使用用户名密码从授权服务器获取令牌</li><li>客户端凭证模式：一般用于资源服务器是应用的一个后台模块，客户端向认证服务器验证身份来获取令牌</li><li>授权码模式：是功能最完整、流程最严密的授权模式，code保证了token的安全性，即使code被拦截，由于没有app_secret，也是无法通过code获得token的，其主要就是appId+appSecret+code<img src=/images/pasted-62.png width=60% style="border:1px solid orange" alt=OAuth2 /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap</title>
      <link href="/2020/02/24/TreeMap/"/>
      <url>/2020/02/24/TreeMap/</url>
      
        <content type="html"><![CDATA[<h4 id="TreeMap基础信息"><a href="#TreeMap基础信息" class="headerlink" title="TreeMap基础信息"></a><strong>TreeMap基础信息</strong></h4><ul><li>继承自NavigableMap&gt;SortedMap，实现keySet、values等方法</li><li>是有序的，TreeMap有序是通过Comparator来进行比较的，如果变量comparator=null，则使用自然顺序</li><li>如果TreeMap构造时，传入Comparator，需要在Comparator中判断key=null，防止npe，不传则默认使用compareTo，这时key不能为null，且传入的对象必须实现了Comparable接口</li><li>存储结构是红黑树，时间复杂度可以保证为log(n)</li><li>TreeMap非同步的，想要同步可以使用Collections来进行封装</li></ul><img src=/images/pasted-59.png style="border:1px solid orange" width=70%  alt=比较方法  /><img src=/images/pasted-58.png style="border:1px solid orange" width=70%  alt=继承类图  />]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo命令</title>
      <link href="/2020/02/22/hexo%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/22/hexo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a><strong>相关命令</strong></h4><p>hexo init  #安装hexo后初始化一个空项目<br>hexo generate 或者 hexo g  #生成静态文件<br>hexo server 或者 hexo s  #启动服务器<br>hexo clean  #清除缓存文件<br>hexo –debug  #启动并开启调试模式</p>]]></content>
      
      
      <categories>
          
          <category> 命令大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web知识</title>
      <link href="/2020/02/22/Web%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/02/22/Web%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="forward和redirect区别"><a href="#forward和redirect区别" class="headerlink" title="forward和redirect区别"></a><strong>forward和redirect区别</strong></h4><p>从本质来说</p><ul><li>forward是服务端行为</li><li>redirect是客户端行为<br>从浏览器地址栏来说</li><li>forward是转发，是服务器内部重定向，只是将对应的内容读出来返回前端，浏览器地址不变</li><li>redirect是重定向，返回浏览器一个302的码，由浏览器去访问新的地址<br>从数据共享来说</li><li>forward整个过程用的是同一个request，能将信息带到被重定向的页面，所以能数据共享</li><li>redirect则不能数据共享<br>从运用场景来说</li><li>forward一般用于用户登录的时候，根据角色转发到相应的模块</li><li>redirect一般用于用户注销登录时返回主页，或跳转其他页面<br>从效率来说</li><li>foreard 高</li><li>redirect 低<br>从请求次数来说</li><li>forward 一次</li><li>redirect 两次，先拿到码，再去请求其他页面</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql执行过程</title>
      <link href="/2020/02/22/Sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/02/22/Sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="一条查询sql的执行过程"><a href="#一条查询sql的执行过程" class="headerlink" title="一条查询sql的执行过程"></a><strong>一条查询sql的执行过程</strong></h4><p><img src="/images/pasted-56.png" style="border:2px red solid" align=center title="sql执行过程" /><br/></p><ul><li>mysql客户端按照协议将SQL发送到服务端，SQL到达服务端后，服务端会新起一个线程去执行sql</li><li>执行时首先判断前6个字符是否为select，并且语句中否带有SQL_NO_CACHE关键字，如果有则进入缓存查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/2020/02/21/volatile/"/>
      <url>/2020/02/21/volatile/</url>
      
        <content type="html"><![CDATA[<h4 id="可见性关键字"><a href="#可见性关键字" class="headerlink" title="可见性关键字"></a><strong>可见性关键字</strong></h4><ul><li>线程在执行过程中，不会在ThreadLocal中缓存，强制线程从主存中获取变量的值</li><li>常用于多线程之间共享变量，只能保证当时读取的是最新的，但是不能保证原子性</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized</title>
      <link href="/2020/02/21/synchronized/"/>
      <url>/2020/02/21/synchronized/</url>
      
        <content type="html"><![CDATA[<h4 id="同步关键字粒度"><a href="#同步关键字粒度" class="headerlink" title="同步关键字粒度"></a><strong>同步关键字粒度</strong></h4><ul><li>作用于类Class</li><li>作用于对象Object</li><li>作用于方法Method</li><li>作用于代码块</li></ul><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h4><ul><li>给资源加锁，保证同一时间点只有一个线程能进入锁定的区域，能保证原子性</li><li>JDK1.6后有提升 对象头部的MarkWord<ul><li>无锁 记录 01</li><li>偏向锁 记录 01</li><li>轻量级锁 记录 00</li><li>重量级锁 记录 10</li><li>GC 记录 11<br><img src="/images/pasted-42.png" alt="对象头锁"></li></ul></li><li>不可重入锁：就是每次请求锁，都需要竞争，即使上一次刚获得过锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见问题</title>
      <link href="/2020/02/01/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/01/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="Springboot中-Async无效"><a href="#Springboot中-Async无效" class="headerlink" title="Springboot中@Async无效"></a>Springboot中@Async无效</h4><ul><li>在@SpringBootApplication启动类 添加注解@EnableAsync</li><li>异步方法使用注解@Async ,返回值为void或者Future</li><li>异步方法和调用方法一定要，写在不同的类中，如果写在一个类中,是没有效果的</li><li>使用@Autowire 和 @Layz</li></ul><h4 id="Map使用Integer做key，json返回值为空"><a href="#Map使用Integer做key，json返回值为空" class="headerlink" title="Map使用Integer做key，json返回值为空"></a>Map使用Integer做key，json返回值为空</h4><ul><li>不要使用Integer作为key，在转json是会被默认转为String，将Integer改成String做key</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>沟通技巧</title>
      <link href="/2020/01/03/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/01/03/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="分角色沟通"><a href="#分角色沟通" class="headerlink" title="分角色沟通"></a><strong>分角色沟通</strong></h4><p>作为一个项目的设计者，有以下注意点</p><ul><li>与产品：方向要准、流程要清，要宏观思维，沟通更需要广度，要放弃细节，不用说具体设计，而应该说这种设计所导致的宏观表象就可以了，主要聊整体业务流程，后期规划，同时结合当前现状，提出意见，对于天马行空的想法，背离当前的主要目标，一定要委婉的拒绝</li><li>与团队成员：抓细节，制定方法论，先从整体上展示规划，明确每个人所处的位置和任务，要深入细节，将产品需求分解细化的说，关注具体的实现策略选择和系统思维的维护上，同时放开一定的空间，让团队成员能自我发挥，培养小组长或模块总负责，同时要经常收集开发的建议，培养大家团队思维</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注册登录</title>
      <link href="/2020/01/02/%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95/"/>
      <url>/2020/01/02/%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-53.png" alt="注册登录"></p>]]></content>
      
      
      <categories>
          
          <category> 业务知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2019/12/25/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/12/25/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>Bloom Filter实际是一种数据结构，实际是一个很长的二进制向量或者数组，和一系列的随机映射函数，它可以用来告诉你某个元素一定不存在和可能存在于某个集合中，优点是空间占用少，查询效率高，缺点是有一定的误识率和删除困难</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>通过hash算法，将一个元素映射成一个位阵列的一个点，这样一来，我们只需要看这个点是不是1，就知道集合中是否存在该值，但是hash会出现hash碰撞，就需要采用多个hash，这样一个元素hash后会存在于多个点上，如果有一个点上为0，则元素一定不存在于集合中，但是如果多个点上都为1，也不能说明集合中一定有这个元素，因为随着元素的增多，置为1的点也越来越多，有可能多个bit点上已经被其他元素的计算值1占据了</p><h4 id="如何删除"><a href="#如何删除" class="headerlink" title="如何删除"></a><strong>如何删除</strong></h4><p>目前只支持add和isExist操作，因为删除A的某个bit位时，可能B的bit位也是这个，解决办法是计数删除，bit位上每中一次，就+1，删除就-1</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h4><p>可以用来判断某个值一定不存在，从而减少后续操作，或者去数据库查询等</p><h4 id="大value拆分"><a href="#大value拆分" class="headerlink" title="大value拆分"></a><strong>大value拆分</strong></h4><p>redis因为支持setbit和getbit，又是基于内存的，天然适合用于做布隆过滤器，但是需要注意当值越来越多时，易形成大value，应该使用多个bitmap，将key分散的存储在这些bitmap中</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>基于guava包提供的BloomFilter，开箱即用</li><li>基于redis的getbit，setbit实现<br>参考：<a href="https://www.cnblogs.com/CodeBear/p/10911177.html" target="_blank" rel="noopener">布隆过滤器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2019/12/25/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/12/25/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a><strong>字体颜色</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=red size=100&gt;123&lt;/font&gt;  size字体大小，最大100</span><br></pre></td></tr></table></figure><h4 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a><strong>设置图片大小</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/images/pasted-43.png&quot; width = &quot;50%&quot; height = &quot;100%&quot; div align=center alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="设置脚标"><a href="#设置脚标" class="headerlink" title="设置脚标"></a><strong>设置脚标</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x&lt;sup&gt;n&lt;/sup&gt;       x的n次幂</span><br><span class="line">log&lt;sub&gt;2&lt;/sub&gt;n    log2n</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法概念</title>
      <link href="/2019/12/25/%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/12/25/%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a><strong>分治法</strong></h4><p>将大问题分解成<font color=red>若干相互独立的子问题</font>，解决这些小问题之后，再去合并小问题的结果，向上求得大问题的解，是一个由上至下的递归过程</p><ul><li>划分：既然是分治，当然需要把规模为n的原问题划分为k个规模较小的子问题，并尽量使这k个子问题的规模大致相同</li><li>求解子问题：各子问题的解法与原问题的解法通常是相同的，可以用递归的方法求解各个子问题，有时递归处理也可以用循环来实现</li><li>合并：把各个子问题的解合并起来，合并的代价因情况不同有很大差异，分治算法的有效性很大程度上依赖于合并的实现</li></ul><h4 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a><strong>贪心法</strong></h4><p>所求问题的整体最优解可以通过一系列局部最优的选择（即贪心选择）来达到，它根据当前的已有的信息作出局部最优解，并不关心整体是不是最优，所以一般用来得到近似最优解</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h4><p>动态规划是一种通过“大而化小”的思路解决问题的思想，将大问题分解成<font color=red>若干相互重叠的子问题</font>，将子问题的解求解一次并填入表中，当需要再次求解此子问题时，可以通过查表获得该子问题的解而不用再次求解，从而避免了大量重复计算</p><ul><li>分段：将原问题分解为若干个相互重叠的子问题</li><li>分析：分析问题是否满足最优性原理，找出动态规划函数的递推式</li><li>求解：利用递推式自底向上计算，实现动态规划过程</li></ul><p><strong>动态规划是自下而上，通过小问题的解，逐步往上推，直到的出结果，采用的是循环迭代，而不是递归</strong><br><strong>常见类型</strong></p><ul><li>矩阵型</li><li>序列型</li><li>双序列型</li><li>划分型</li><li>区间型</li><li>背包型</li><li>状态压缩型</li><li>树型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql常用语句</title>
      <link href="/2019/12/24/Mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/12/24/Mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -u root -P 3306 -p</span><br></pre></td></tr></table></figure><h4 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a><strong>用户与权限</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.USER_PRIVILEGES;</span><br><span class="line"></span><br><span class="line">SELECT user,host,grant_priv,super_priv FROM mysql.user;</span><br><span class="line"></span><br><span class="line">// root@% 权限不足时，需要重启mysql</span><br><span class="line">update mysql.user set Grant_priv=&apos;Y&apos;,Super_priv=&apos;Y&apos; where user = &apos;root&apos; and host = &apos;%&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">service mysqld restart</span><br><span class="line"></span><br><span class="line">CREATE USER &apos;用户名&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line">GRANT ALL ON schema名.* TO &apos;username&apos;@&apos;%&apos;;</span><br><span class="line">GRANT SELECT,UPDATE ON schema名.* TO &apos;username&apos;@&apos;%&apos;;</span><br><span class="line"></span><br><span class="line">//更新用户密码</span><br><span class="line">UPDATE user SET Password=PASSWORD(&apos;123456&apos;) where USER=&apos;root&apos;;</span><br></pre></td></tr></table></figure><h4 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a><strong>行转列</strong></h4><p>使用case进行判断，或者if，groupby进行分组求和或取一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT user_name ,</span><br><span class="line">    MAX(CASE course WHEN &apos;数学&apos; THEN score ELSE 0 END ) 数学,</span><br><span class="line">    MAX(CASE course WHEN &apos;语文&apos; THEN score ELSE 0 END ) 语文,</span><br><span class="line">    MAX(CASE course WHEN &apos;外语&apos; THEN score ELSE 0 END ) 外语,</span><br><span class="line">    MAX(CASE course WHEN &apos;政治&apos; THEN score ELSE 0 END ) 政治,</span><br><span class="line">    MAX(CASE course WHEN &apos;历史&apos; THEN score ELSE 0 END ) 历史</span><br><span class="line">FROM tb_score</span><br><span class="line">GROUP BY USER_NAME;</span><br></pre></td></tr></table></figure><div style="float:left">  <img src="/images/pasted-43.png" width = "50%" height = "100%" div align=left alt="" />  <img src="/images/pasted-44.png" width = "45%" height = "100%" div align=right style="margin-top:10%" alt="" /></div><h4 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a><strong>列转行</strong></h4><p>使用union进行联合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT user_name, &apos;数学&apos; AS corse, shuxue AS score</span><br><span class="line">FROM tb_score1</span><br><span class="line">UNION</span><br><span class="line">(SELECT user_name, &apos;语文&apos; AS corse, yuwen AS score FROM tb_score1)</span><br><span class="line">UNION</span><br><span class="line">(SELECT user_name, &apos;外语&apos; AS corse, waiyu AS score FROM tb_score1)</span><br><span class="line">UNION</span><br><span class="line">(SELECT user_name, &apos;政治&apos; AS corse, zhengzhi AS score FROM tb_score1)</span><br><span class="line">UNION</span><br><span class="line">(SELECT user_name, &apos;历史&apos; AS corse, lishi AS score FROM tb_score1);</span><br></pre></td></tr></table></figure><div style="float:left">  <img src="/images/pasted-45.png" width = "58%" height = "100%" div align=left style="margin-top:10%" alt="" />  <img src="/images/pasted-46.png" width = "40%" height = "100%" div align=right  alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> 常用代码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux脚本</title>
      <link href="/2019/12/24/linux%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/12/24/linux%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h4 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a><strong>start.sh</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">work_dir=`cd $(dirname $0); pwd -P`</span><br><span class="line"></span><br><span class="line">version=$1</span><br><span class="line">if [ -z &quot;$version&quot; ];then</span><br><span class="line">   echo &quot;请指定版本&quot;</span><br><span class="line">   exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">active_profile=prod</span><br><span class="line"></span><br><span class="line">echo &quot;启动开始&quot;</span><br><span class="line"></span><br><span class="line">java -server -Xms256m -Xmx256m -jar -Dfile.encoding=UTF-8 -Djava.io.tmpdir=/usr/local/best/tmp -jar best-back-$version.jar --spring.profiles.active=$active_profile &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">echo $! &gt; $work_dir/best-back.pid</span><br><span class="line"></span><br><span class="line">echo &quot;启动完成&quot;</span><br></pre></td></tr></table></figure><h4 id="stop-sh"><a href="#stop-sh" class="headerlink" title="stop.sh"></a><strong>stop.sh</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_dir=`cd $(dirname $0); pwd -P`</span><br><span class="line"></span><br><span class="line">cat $work_dir/best-back.pid | xargs kill -9</span><br></pre></td></tr></table></figure><h4 id="restart-sh"><a href="#restart-sh" class="headerlink" title="restart.sh"></a><strong>restart.sh</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">work_dir=`cd $(dirname $0); pwd -P`</span><br><span class="line"></span><br><span class="line">version=$1</span><br><span class="line">if [ -z &quot;$version&quot; ];then</span><br><span class="line">   echo &quot;请指定版本&quot;</span><br><span class="line">   exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sh $work_dir/stop.sh</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">sh $work_dir/start.sh $version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用代码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>幂等设计</title>
      <link href="/2019/12/23/%E5%B9%82%E7%AD%89%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/12/23/%E5%B9%82%E7%AD%89%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="mvcc模式"><a href="#mvcc模式" class="headerlink" title="mvcc模式"></a><strong>mvcc模式</strong></h4><p>通过版本号(乐观锁)方式来实现，主要是通过数据库来实现</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h4><p>每次更新都加锁，这个并发效率低</p><h4 id="去重表"><a href="#去重表" class="headerlink" title="去重表"></a><strong>去重表</strong></h4><p>通过数据库唯一索引实现</p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a><strong>状态机</strong></h4><p>业务单上有个状态，一版存在有限状态机，当数据过来时，如果相对当前状态来说，已经是前面的状态了，理论上是不能变更的</p><h4 id="唯一令牌"><a href="#唯一令牌" class="headerlink" title="唯一令牌"></a><strong>唯一令牌</strong></h4><p>提交时需要带上唯一令牌，此令牌只有一次有效性，可以防止页面重复提交</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h4><p>保证并发请求，只有一个被执行</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h4><p>通过缓存保存已经执行的操作，当请求过来时，先比对一下</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制</title>
      <link href="/2019/12/23/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/12/23/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="记录binlog的三种模式"><a href="#记录binlog的三种模式" class="headerlink" title="记录binlog的三种模式"></a><strong>记录binlog的三种模式</strong></h4><ul><li>基于行模式（Row）：<ul><li>优点：只记录哪条数据被修改了，以及具体的修改细节，不会记录触发器，function等执行</li><li>缺点：会产生大量的日志内容</li></ul></li><li>基于sql模式（Statement）：<ul><li>优点：以sql方式记录语句，包含函数和触发器等执行</li><li>缺点：由于使用函数等，比如sleep，会造成主从同步时出现错误，复制越来越复杂</li></ul></li><li>mixed模式：实际是结合前面两种方式，根据sql语句，来确定是使用行模式还是sql模式，比如ddl使用statement，update和delete就使用基于行模式</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>主从同步过程中主服务器有一个工作线程I/O dump thread，从服务器有两个工作线程I/O thread和SQL thread。</li><li>主库把外界接收的SQL请求记录到自己的binlog日志中，从库的I/O thread去请求主库的binlog日志，并将binlog日志写到中继日志中，然后从库重做中继日志的SQL语句。主库通过I/O dump thread给从库I/O thread传送binlog日志</li><li>如果是一主多从的架构，可设置先给一从，然后同步给其他从，或者设置一个从只负责转发日志给其他从<br><img src="/images/pasted-41.png" alt="主从同步"></li></ul><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a><strong>异步复制</strong></h4><p>主库写完binlog后，立马返回给客户端，无需等待binlog日志传递给从库，这种如果主库挂了，未同步的数据就丢失了</p><h4 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a><strong>半同步复制</strong></h4><ul><li>AFTER_COMMIT 先提交，后同步<ul><li>主库将每个事务写入binlog中</li><li><font color="red">主库提交数据</font></li><li>传递biblog给从库刷新到relaylog中</li><li>主库开始等待从库反馈，直到收到从库返回结果后</li><li>主库将提交结果反馈给客户端</li></ul></li><li>AFTER_SYNC 先同步，后提交<ul><li>主库将每个事务写入binlog中</li><li>传递binlog给从库刷新到relaylog中</li><li>主库开始等待从库反馈，直到收到从库返回结果后</li><li><font color="red">主库提交数据</font></li><li>主库将提交结果反馈给客户端</li></ul></li></ul><p><strong>AFTER_SYNC模式下，即使主库宕机，从库的relaylog中页保存了主库提交的记录，不会造成数据丢失</strong></p><h4 id="GTID复制"><a href="#GTID复制" class="headerlink" title="GTID复制"></a><strong>GTID复制</strong></h4><p>GTID又叫全局事务ID，是一个以提交事务的编号，并且是一个全局唯一的编号。GTID是由server_uuid和事务id组成的，即GTID=server_uuid:transaction_id<br><strong>GTID存在的价值</strong></p><ul><li>一个事务对应一个唯一ID，一个GTID在一个服务器上只会执行一次;</li><li>GTID是用来代替传统复制的方法，GTID复制与普通复制模式的最大不同就是不需要指定二进制文件名和位置;</li><li>减少手工干预和降低服务故障时间，当主机挂了之后通过软件从众多的备机中提升一台备机为主机;  </li></ul><p><strong>GTID限制条件</strong></p><ul><li>不支持非事务引擎;</li><li>不支持create table … select 语句复制(主库直接报错);(原理: 会生成两个sql, 一个是DDL创建表SQL, 一个是insert into 插入数据的sql; 由于DDL会导致自动提交, 所以这个sql至少需要两个GTID, 但是GTID模式下, 只能给这个sql生成一个GTID)</li><li>不允许一个SQL同时更新一个事务引擎表和非事务引擎表;</li><li>在一个复制组中，必须要求统一开启GTID或者是关闭GTID;</li><li>开启GTID需要重启 (mysql5.7除外);</li><li>开启GTID后，就不再使用原来的传统复制方式;</li><li>对于create temporary table 和 drop temporary table语句不支持;</li><li>不支持sql_slave_skip_counter;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SPI</title>
      <link href="/2019/12/23/SPI/"/>
      <url>/2019/12/23/SPI/</url>
      
        <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>SPI Service Provider Interface，是一种服务发现机制，它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类，这一机制为很多框架扩展提供了可能，比如在Dubbo、JDBC中都使用到了SPI机制</p><h4 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a><strong>存在原因</strong></h4><p>Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制，是为了实现面向接口编程，将实现类的装配权，移动到程序外，类似ioc，核心思想就是 <strong>解耦</strong></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略<br>比较常见的例子：</p><ul><li>数据库驱动加载接口实现类的加载，JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类</li><li>Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li><li>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><p>要使用Java SPI，需要遵循如下约定：</p><ul><li>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li><li>接口实现类所在的jar包放在主程序的classpath中；</li><li>主程序通过 java.util.ServiceLoder或sun.misc.Service 动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li><li>SPI的实现类必须携带一个不带参数的构造方法；</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-网络知识</title>
      <link href="/2019/12/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/12/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a><strong>TCP和UDP区别</strong></h4><p>答：TCP是面向连接的，是可靠的，有状态传输，需要三次握手四次挥手，确保数据完整，不会丢数据，没有重复，且是顺序送达，还有确认、窗口、重传、拥塞控制机制<br>UDP是无连接的，只管发信息，不管是否送达，不可靠，无状态传输<br><strong>缺点</strong></p><ul><li>TCP 慢，效率低，占用资源多，实现复杂，被攻击漏洞多</li><li>UDP 不安全，网络环境差易丢包</li></ul><p><strong>适合场景</strong></p><ul><li>TCP 需要可靠传输，少量数据，如http，https，ftp，pop，smtp等</li><li>UDP 传输快，适合对可靠性要求低的，大量数据传输场景，如语音、视频、TFTP等</li></ul><h4 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a><strong>网络攻击</strong></h4><ul><li>拒绝服务攻击 Denial of Service，简称DOS：通过一定的手段，使目标服务器不能对外提供服务或宕机<ul><li>迫使服务器缓冲区满，不接受新的请求</li><li>使用ip欺骗，迫使服务器把非法连接复位，影响合法用户的连接</li></ul></li><li>DDoS(Distributed Denial Of Service分布式拒绝服务攻击)</li></ul><p><strong>TCP SYN Flood</strong></p><ul><li>syn洪水攻击，第一次客户端发送SYN给服务器，服务器收到后，发送SYN+ACK给客户端，假设这时候客户端宕机，那服务端会等待一段时间，30s-2min，期间还会重试，服务端维护着这样一个半连接的表，导致服务器的资源被大量占用，无法处理正常的请求，解决办法：增加一个syn cookie防火墙，原理是增加中间层，将三次握手拆解，第一次还是有C发给S，第二次有防火墙返回ACK给C，如果客户端返回ACK给防火墙，那么防火墙和C的连接就建立好了，接着防火墙再去发送ACK给S，这时防火墙和S的连接也建立好了，最后防火墙来转发CS之间的数据</li></ul><p><strong>TCP RST攻击</strong></p><ul><li>通过伪造已经建立好连接的ip，发送带有RST(复位)的TCP报文给服务端，服务端收到后会清空缓冲区，断开连接，导致正常客户端需要重新跟服务端建立连接</li></ul><p><strong>connect reset by peer</strong><br>C和S已经正常建立连接，正在通讯时，C向S发送了FIN包要求关连接，S发送ACK后，C网断了，C通过若干原因放弃了这个连接（例如进程重启）。网络恢复之后，S又开始或重发数据包，C不知道这连接哪来的，就发RST包强制把连接关闭，S收到后会出现connect reset by peer错误。</p><p>参考：<br><a href="https://blog.csdn.net/guowenyan001/article/details/11777361" target="_blank" rel="noopener">网络攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调用三方设计</title>
      <link href="/2019/12/20/%E8%B0%83%E7%94%A8%E4%B8%89%E6%96%B9%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/12/20/%E8%B0%83%E7%94%A8%E4%B8%89%E6%96%B9%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="调用三方系统"><a href="#调用三方系统" class="headerlink" title="调用三方系统"></a><strong>调用三方系统</strong></h4><ul><li>同步调用：调用指定接口，同步返回</li><li>同步调用，异步通知：先调用接口发起任务，后三方回调我方接口，通知任务执行结果</li></ul><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a><strong>关注点</strong></h4><ul><li>三方系统支持的qps，即每秒我能调用它多少次</li><li>三方系统的rt，即每调用一次，平均耗时是多少，还有超时我们怎么处理</li><li>三方系统的异常信息，即三方系统返回的错误码，都是什么意思，出现相应的码，我们该怎么处理，比如账户余额不足，接口请求频繁</li><li>三方系统存活情况，宕机怎么处理</li><li>三方系统回调消息，幂等怎么做</li></ul><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a><strong>时序图</strong></h4><p><img src="/images/pasted-39.png" alt="时序图"><br>其中4和5，可以做同步按照456顺序(比如：oss文件直传)，也可做异步，45与6不相干(比如：支付宝微信支付)</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><p>三方对接流程 流程很简单，发起请求，获取同步结果异步结果，难点不在对接上，难在用户操作和三方的未知性不可控性上，保证系统的高可用上</p><ul><li>针对用户，我们要防刷单，web端要做图形验证码，短信验证码，服务端要做短信验证码获取次数限制，单日提交同类型三方操作不能超过3次等</li></ul><p><strong>针对三方，主要有以下几点</strong></p><ul><li>第一：我们要记录什么信息，怎样做到好查询，好排错，好统计</li><li>第二：我们有对接很多三方，接口吞吐量、调用性能参差不齐、费率也是不一样，如何做到流量规划、流量分发、实时计费、每日对账等</li><li>第三：三方可能出现各种各样的异常，超时，账户余额不足，服务不可用等，这些三方可能都不会事先通知，我们调用后才知道，出现这些问题，我们如何做到心跳监测、主备切换、故障转移、失联修复、超时预警、实时监控等</li><li>第四：针对三方异步回调，我们要做什么？安全校验、回调幂等、限流和熔断、无回调复查</li><li>第五：数据存储，针对原始数据，要进行加密，存储在哪mongdb，oss等系统</li><li>第六：数据如何使用，提供什么程度的api，或者上报给哪些系统</li></ul><img src="/images/pasted-52.png" width = "50%" height = "100%" div align=center alt="概要" /><ul><li><p>唯一ID：我们应该为所有请求设置唯一交易号（基于雪花算法、百度UidGenerator），记录请求发起ip，目标地址，三方返回的交易号，调用的结果，调用耗时，报错信息，数据状态，发起时间等，在日志中将此交易号一直输出，好去跟踪</p></li><li><p>心跳监测：调用三方指定的接口，去监测当前在用渠道的可用性，如果三方没提供对应接口，我们要通过最近一段时间的调用情况来预测，比如最近5次时间情况，最近10次有2次失败等</p></li><li><p>流量规划：多个第三方，根据渠道吞吐量高低，渠道响应块慢，合理的配置流量权重，通过redis来存储一个list，根据权重在list中重复渠道数，每次随机取值确定渠道<br><font color=blue><em>优化点：目前是人工基于历史数据的判断，后面可以改成自动均衡，同时也可以让渠道注册在zk节点上，服务端本地有内存缓存，通过监听节点的变化来刷新缓存</em></font><br>①实现方式：配置文件、数据库配置、缓存计数器、页面修改时，主动推送缓存更新)<br>②知识点：高并发下redis缓存更新策略，要结合业务和技术代价选择使用</p></li><li><p>主备切换：配置额外的备用通道，当主通道不可用时，增加备选通道，通过上面的list慢慢的加入</p></li><li><p>故障转移：failover，出现错误，针对返回异常，如502 bad gateway，504 bad gateway timeout，403等，快速的切换到其他通道，这里的失败也需要记录，用于做存活监控</p></li><li><p>超时预警：针对多次出现超时等信息，进行邮件通知，短信通知</p></li><li><p>失联修复：出现问题，及时联系三方，通过隔一段时间，去查询一次，确定渠道恢复，然后重新加入到可用渠道队列中</p></li><li><p>回调幂等：通过唯一交易号，进行拦截，先根据交易号进行时间判断，如果超过某个时间差，直接返回成功，相当于丢弃了，查询缓存，如果已经回调成功的，直接返回成功，如果未完成的，更新数据库状态，通过state做乐观锁控制重复更新，同时将交易号存储到缓存中，设置一段时间有效期</p></li><li><p>安全校验：回调通常要进行签名验证，对称加密md5，非对称加密rsa，回调信息中有些接口支持返回传入的自定义参数，基于这个也可以做更强的内容验证</p></li><li><p>限流熔断：防止第三方由于某些原因出现重复回调，可以对接sentinel，hytrix这种，也可以基于guava的RateLimter实现局部限流，基于redis实现令牌桶限流也可以<br><font color=blue><em>优化点：目前是本地限流，后面可增加全局限流</em></font></p></li><li><p>请求复查：就是一直没收到回调或者有新的请求过来，先去查询上一次的结果，我是使用的定时任务，扫描这表里面一定时间内未回调的数据，去三方查询，把结果更新回来，再就是业务方再次发起时，如果数据库已经有调用记录的但是没返回的，也会去三方查一次</p></li><li><p>实时监控：通过kafka进行埋点，量小通过mysql展示，量大走流计算做实时报表展示</p></li><li><p>实时计费：主要是通过写kafka消息，异步去做的统计和页面展示</p></li><li><p>每日对账：自动化对账，通过定时任务，统计当日调用量，与三方系统的接口访问次数去比对，有些三方不一定有这接口提供<br><font color=blue><em>优化点：将整体流程梳理一遍，看看哪些地方还能提供参数化配置，有些页面还不完善，要修改</em></font></p></li></ul><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h4><ul><li>redis缓存的更新和持久化</li><li>限流 滑动窗口计数器 漏桶 令牌桶 </li><li>Ratelimiter实现本地限流就是用过sync锁实现，acquire时获取锁，获取的同时，在等待时间内，还会调用生成函数，持续往里面加令牌</li><li>熔断 </li><li>mysql数据库的主从同步</li><li>zk的节点事件监控</li><li>分布式调度框架</li><li>先搭建开源框架，再通过框架的范围推广，去影响整个行业的接口设计和功能支撑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现死锁代码</title>
      <link href="/2019/12/20/%E5%AE%9E%E7%8E%B0%E6%AD%BB%E9%94%81%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/12/20/%E5%AE%9E%E7%8E%B0%E6%AD%BB%E9%94%81%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>思路：启动两个线程t1，t2，指定两个对象obj1，obj2，t1先锁obj1，在代码块中再锁obj2，线程t2先锁obj2，在代码块中再锁obj1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Component;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * Dead lock example </span><br><span class="line"> *  </span><br><span class="line"> * @author Josh Wang(Sheng) </span><br><span class="line"> * </span><br><span class="line"> * @email  josh_wang23@hotmail.com </span><br><span class="line"> */  </span><br><span class="line">@Component  </span><br><span class="line">public class DeadLock &#123;    </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">        System.out.println(&quot; start the example ----- &quot;);  </span><br><span class="line">        final Object obj_1 = new Object(), obj_2 = new Object();    </span><br><span class="line">            </span><br><span class="line">        Thread t1 = new Thread(&quot;t1&quot;) &#123;    </span><br><span class="line">            @Override    </span><br><span class="line">            public void run() &#123;    </span><br><span class="line">                synchronized (obj_1) &#123;    </span><br><span class="line">                    try &#123;    </span><br><span class="line">                        System.out.println(&quot;thread t1 start...&quot;);  </span><br><span class="line">                        Thread.sleep(3000);    </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;    </span><br><span class="line">                        </span><br><span class="line">                    synchronized (obj_2) &#123;    </span><br><span class="line">                        System.out.println(&quot;thread t1 done....&quot;);    </span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;;    </span><br><span class="line">            </span><br><span class="line">        Thread t2 = new Thread(&quot;t2&quot;) &#123;    </span><br><span class="line">            @Override    </span><br><span class="line">            public void run() &#123;    </span><br><span class="line">                synchronized (obj_2) &#123;    </span><br><span class="line">                    try &#123;    </span><br><span class="line">                        System.out.println(&quot;thread t2 start...&quot;);  </span><br><span class="line">                        Thread.sleep(3000);    </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;    </span><br><span class="line">                        </span><br><span class="line">                    synchronized (obj_1) &#123;    </span><br><span class="line">                        System.out.println(&quot;thread t2 done...&quot;);    </span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;;    </span><br><span class="line">            </span><br><span class="line">        t1.start();    </span><br><span class="line">        t2.start();    </span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用代码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM性能调优</title>
      <link href="/2019/12/20/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2019/12/20/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a><strong>参数调优</strong></h4><p>-Xmx1g：JVM可使用的最大内存<br>-Xms1g：JVM初始内存  此值可以和Xmx相同，避免每次GC后jvm重新调整内存<br>-Xmn128m：设置年轻代大小<br>-Xss128k：设置每个线程的堆栈大小，1.5后默认是1g，减小这个值，能产生更多的线程，一个进程的线程数是有限的，经验值是在3000~5000</p><p>-XX:NewRatio=4：设置年轻代和年老代的比值<br>-XX:SurvivorRatio=4：设置年轻代中eden区和surrivor区比值<br>-XX:MaxPermSize=256m：设置永久代大小 1.8以下<br>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄</p><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a><strong>jstack</strong></h4><p>用来查看某个java进程内线程的堆栈信息<br>jstack [option] pid<br>jstack [option] executable core<br>jstack [option] [server-id@]remote-hostname-or-ip </p><p>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况<br>-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）  </p><p><strong>找出死锁位置</strong><br>双线程模拟死锁</p><ul><li>找到进程号，执行 jstack -l pid &gt; deadlock.jstack</li><li>查看deadlock.jstack文件，搜索deadlock关键字<br><img src="/images/pasted-37.png" alt="死锁"></li></ul><p>多线程频繁操作hashmap导致锁，步骤同上<br><img src="/images/pasted-38.png" alt="hashmap死锁"></p><p><strong>找出java进程中最耗费cpu的java线程</strong></p><ul><li>执行 top -Hp pid 查看进程对应的线程信息，找出最耗cpu的线程id[tid]</li><li>执行 printf “%x\n” tid 得到线程id的16进制值[tid16]</li><li>执行 jstack pid | grep tid16 可以看到cpu主要消耗在哪个类的哪个方法上<br><img src="/images/pasted-31.png" alt="线程耗时"></li></ul><h4 id="jamp和jhat"><a href="#jamp和jhat" class="headerlink" title="jamp和jhat"></a><strong>jamp和jhat</strong></h4><p>jmap用来导出堆内存，然后是用jhat进行分析<br>jmap -heap pid 可以查看GC收集器，堆内存参数配置，堆内存的使用情况<br><img src="/images/pasted-32.png" alt="堆内存"><br>jmap -histo pid 查看堆内存中对象的数目，大小等<br>jmap -dump:format=b,file=dumpFileName pid 通过导出dump文件，再到jhat中分析<br>jmap -dump:format=b,file=/root/dump.dat 28561<br>jhat -port 8888 /root/dump.dat 启动的是web server，可以去web查看<br><img src="/images/pasted-33.png" alt="jhat"><br><img src="/images/pasted-34.png" alt="jhat-web"></p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a><strong>jstat</strong></h4><p>jstat是jvm统计监测工具，可以看各个区内存和GC情况<br>jstat -gc pid 采样间隔毫秒 采样数量<br>jstat -gc 28561 250 6<br><img src="/images/pasted-35.png" alt="jstat"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）  </span><br><span class="line">EC、EU：Eden区容量和使用量  </span><br><span class="line">OC、OU：年老代容量和使用量  </span><br><span class="line">PC、PU：永久代容量和使用量  </span><br><span class="line">YGC、YGT：年轻代GC次数和GC耗时  </span><br><span class="line">FGC、FGCT：Full GC次数和Full GC耗时  </span><br><span class="line">GCT：GC总耗时</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA异常类</title>
      <link href="/2019/12/18/JAVA%E5%BC%82%E5%B8%B8%E7%B1%BB/"/>
      <url>/2019/12/18/JAVA%E5%BC%82%E5%B8%B8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><ul><li>Exception和Error都继承了Throwable，java规定只有Throwable类型的实例才可以被throw和catch</li><li>Error是指正常情况下，不大可能出现的异常，绝大部分的Error会导致程序不正常，无法继续运行，如oom</li><li>Exception是程序运行过程中，可以预料的意外情况，并且应该被捕获，进行相应的处理</li><li>Exception又分受检异常和非受检异常，受检异常是在源代码上进行显式捕获的，非受检异常即运行时异常，如npe，ArrayIndexOutOfBoundsException之类的</li></ul><h4 id="异常结构"><a href="#异常结构" class="headerlink" title="异常结构"></a><strong>异常结构</strong></h4><p><img src="/images/pasted-30.png" alt="异常结构"></p><h4 id="异常处理基本原则"><a href="#异常处理基本原则" class="headerlink" title="异常处理基本原则"></a><strong>异常处理基本原则</strong></h4><ul><li>尽量不要捕获Exception这种通用异常，而是应该捕获特定异常，因为软件工程是门协作的艺术，我们读代码的几率远高于写代码，我们有义务让自己的代码能够直观的体现更多的信息，另外也要保证不会捕获我们不希望捕获的异常，比如你可能更希望RuntimeException被扩散出来，供上层处理</li><li>不要生吞(swallow)异常，往往是基于假设这段代码可能不会发生，异常可以忽略，所以不抛出异常，导致出了异常后，没办法定位到是什么原因，哪里产生了异常</li><li>不要e.printStackTrace()去打印异常，尤其是分布式系统，无法找到堆栈轨迹，无疑是给诊断设置障碍</li><li>Throw early，在发现问题的时候，第一时间抛出，能够更加清晰地反映问题，如空值判断，避免通过后续出现的npe去定位</li><li>catch late，要考虑捕获异常后，需要怎么处理？要包含哪些信息？可以保留异常信息，往上层抛出，上层有更清晰的业务逻辑，里面的异常信息要注意安全问题，如数据连接异常没必要打印ip，port等，用户的敏感信息也要脱敏</li></ul><h4 id="异常的注意点"><a href="#异常的注意点" class="headerlink" title="异常的注意点"></a><strong>异常的注意点</strong></h4><ul><li>try-catch代码块，会影响jvm的代码优化，产生性能开销，所以往往推荐仅捕获必要的代码段，尽量不要一个大try块包住整个代码</li><li>java每实例化一个Exception对象，都会对当时的栈进行快照，这是一个相对比较重的操作，如果发生频繁，这个开销不容忽视</li></ul><h4 id="代码中如何设计异常"><a href="#代码中如何设计异常" class="headerlink" title="代码中如何设计异常"></a><strong>代码中如何设计异常</strong></h4>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO知识</title>
      <link href="/2019/12/17/IO%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/12/17/IO%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="linux操作系统底层知识"><a href="#linux操作系统底层知识" class="headerlink" title="linux操作系统底层知识"></a><strong>linux操作系统底层知识</strong></h4><ul><li><p>内核态(内核空间)：操作系统内核，硬件驱动等所在的运行空间</p></li><li><p>用户态(用户空间)：普通应用和服务的运行空间<br>为保证系统安全，用户应用只能访问用户空间，内核应用可访问内核空间和用户空间</p></li><li><p>文件描述符fd(file descriptor)：是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作(包括网络socket操作)的系统调用都通过文件描述符</p></li><li><p>缓存io：操作系统会将io数据缓存在文件系统的页缓存中，即：数据会先拷贝到内核缓冲区，再从内核缓冲区拷贝到程序的地址空间</p></li></ul><h4 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h4><p>基于一个read操作，基本分两阶段：</p><ul><li>①数据准备：数据从资源位置(本地文件系统、网络地址等)拷贝到内核空间</li><li>②数据拷贝：数据从内核空间拷贝到用户空间</li></ul><h4 id="BIO-blocking-IO，阻塞io"><a href="#BIO-blocking-IO，阻塞io" class="headerlink" title="BIO blocking IO，阻塞io"></a><strong>BIO blocking IO，阻塞io</strong></h4><p>是指线程在进行io操作时，读写操作执行完之前，会一直阻塞在那，提供可靠的线性顺序，在①和②都阻塞在那，等待操作完成<br><img src="/images/pasted-26.png" alt="阻塞io"></p><h4 id="NIO-non-blocking-IO，非阻塞io"><a href="#NIO-non-blocking-IO，非阻塞io" class="headerlink" title="NIO non-blocking IO，非阻塞io"></a><strong>NIO non-blocking IO，非阻塞io</strong></h4><p>当用户进程发起read操作时，如果内核中数据没准备好，会立即返回一个error，进程发现error，就再次发起read操作，对于用户进程来说，并没有阻塞在那，一旦数据准备好了，内核会在下次收到read请求时，马上把数据拷贝到用户内存，然后返回，只在②阻塞<br><img src="/images/pasted-27.png" alt="upload successful"><br><strong>nio三种线程模型</strong></p><ul><li>Reactor单线程模型 一个nio线程来处理所有tcp连接读取和写入</li><li>Reactor多线程模型 一个NIO线程-Acceptor线程来接收客户端tcp请求，nio线程池来处理所有读取和写入</li><li>主从Reactor多线程模型 主Reactor也是独立的线程池，负责tcp连接，从rector线程池去处理读写</li></ul><p>最后，对于NIO和传统IO，有一个网友讲的生动的例子：<br>以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当前水龙头，试着打开另一个水龙头（看看有没有水）。当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做其它事去，水接满了，接水工会通知他们。这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。</p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a><strong>IO多路复用</strong></h4><p>IO multiplexing就是我们说的select，poll，epoll，也称这种IO方式为event driven IO，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br><img src="/images/pasted-28.png" alt="io多路复用"></p><ul><li>当用户进程调用了select，那么整个进程就会被block，同时kernel会 “监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程</li><li>IO多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入就绪状态，select()函数就可以返回。</li><li>这里需要使用两个system call（select 和 recvfrom），而blocking IO只调用了一个system call（recvfrom）。但是，用select的优势在于它可以同时处理多个connection。</li><li>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用mutil-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll 的优势并不是对于单个连接能处理得更好，而是在于性能更多的连接</li></ul><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><strong>异步IO</strong></h4><p><img src="/images/pasted-29.png" alt="异步IO"><br>    用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了</p><h4 id="select，poll，epoll区别"><a href="#select，poll，epoll区别" class="headerlink" title="select，poll，epoll区别"></a><strong>select，poll，epoll区别</strong></h4><p>从平台来看</p><ul><li>select 是跨平台的 windows、unix、linux下都有</li><li>poll 在linux、unix下有，windows下没有</li><li>epoll 只有linux特有，unix和windows下没有</li></ul><p>从执行过程来看</p><ul><li>select监视的并等待多个文件描述符的属性发生变化，调用select函数，会阻塞，直到有可读、可写、异常或者超时 时才返回，返回后，可通过遍历fdset确定是哪个fd就绪了，用数组来存储fd，默认支持的是1024个fd</li><li>poll是基于链表来保存fd，没有监视fd数量上限制</li><li>epoll通过epoll_create创建一个用于epoll轮询的描述符，通过epoll_ctl添加/修改/删除事件，通过epoll_wait检查事件，epoll_wait的第二个参数用于存放结果。 epoll与select、poll不同，首先，其不用每次调用都向内核拷贝事件描述信息，在第一次调用后，事件信息就会与对应的epoll描述符关联起来。另外epoll不是通过轮询，而是通过在等待的描述符上注册回调函数，当事件发生时，回调函数负责把发生的事件存储在就绪事件链表中，最后写到用户空间</li></ul><p>总结区别</p><ul><li>操作系统不同，epoll是linux独有</li><li>select和poll每次调用，都需要将要监控的socket列表，从用户空间cpoy到内核空间，而epoll第一次调用时，就已经将事件和fd关联起来了</li><li>select和poll都是基于所有fd轮询，而epoll是基于事件回调，只会去关注就绪链表中的数据</li></ul><p>如果所有socket连接都是活跃的，epoll效率不一定高，但是如果大部分是不活跃的，则epoll效率很高<br>如何避免内存拷贝，epoll通过内核与用户空间mmap同一块内存来实现</p><p>设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？</p><p>epoll的两种工作模式</p><ul><li>LT模式 Level Triggered：水平触发，默认模式，内核会通知开发者某个fd是否就绪，如果开发者不采取任何操作，内核仍会一直通知。</li><li>ET模式 Edge Triggered：边缘触发，当且仅当状态发生变化时才会后的通知，假定开发者第一次接收到通知后，会完整处理该事件，因此内核不会再通知此事件。注意，缓冲区中有数据没处理完，不属于状态变更，即开发者没读取完，也不会再收到通知，所以开发者要确认读取了所有的字节。</li></ul><p>监听套接字即读，适合用LT，可以分多次读，如果是一次读所有的，则可用ET<br>通信套接字即写，LT效率略低，如redis默认；ET效率高，一次就读完，但是编程复杂，要控制不丢数据，如nginx默认</p><p>参考<br><a href="https://www.cnblogs.com/DengGao/p/file_symbol.html" target="_blank" rel="noopener">文件描述符与socket连接</a><br><a href="https://blog.csdn.net/zhaobryant/article/details/80557262" target="_blank" rel="noopener">Linux epoll模型详解及源码分析</a><br><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311" target="_blank" rel="noopener">epoll原理详解及epoll反应堆模型</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-分布式锁</title>
      <link href="/2019/12/12/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/12/12/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a><strong>基于数据库</strong></h4><p>获取锁的时候往数据库插入记录，插入成功获取锁，释放锁时删除数据，这种方式存在单点问题，而且一旦线程挂掉，锁将没办法释放，形成死锁</p><h4 id="基于redis的set-nx"><a href="#基于redis的set-nx" class="headerlink" title="基于redis的set nx"></a><strong>基于redis的set nx</strong></h4><p>redis底层是单线程的</p><ul><li>加锁：setnx(set if not exists)命令已经废弃，取代的是SET lock_key random_value NX PX 5000，NX 代表只在键不存在时，才对键进行设置操作，PX 5000 设置键的过期时间为5000毫秒。</li><li>解锁：解锁也不是随便去del，而是根据上面设置的random_value去判断删除，为了原子性，要使用lua脚本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&apos;get&apos;,KEYS[1]) == ARGV[1] then </span><br><span class="line">   return redis.call(&apos;del&apos;,KEYS[1]) </span><br><span class="line">else</span><br><span class="line">   return 0 </span><br><span class="line">end</span><br></pre></td></tr></table></figure>这个锁是不可重入的，基于redisson的可以实现重入锁，实现原理就是要判断来申请获取锁的线程，是不是已经持有锁的线程，都是通过lua脚本实现<br>参考<a href="https://www.jianshu.com/p/47fd7f86c848" target="_blank" rel="noopener">分布式锁之Redis实现</a></li></ul><h4 id="基于zk节点"><a href="#基于zk节点" class="headerlink" title="基于zk节点"></a><strong>基于zk节点</strong></h4><ul><li>初始化持久性节点 lock</li><li>获取锁时，在lock下创建临时有序节点，通过getChilden获取lock下所有子节点，然后根据序号排序，看当前创建的节点是不是序号最小的，如果是，获得锁，释放时删除节点</li><li>如果不是，就获得当前节点序号的上一个节点序号，并给该节点注册是否存在监听事件，等待上个节点删除后，就能获得锁，只用去监听上一个节点事件，而不是所有节点事件，有效避免惊群效应</li></ul><h4 id="ZK的惊群效应"><a href="#ZK的惊群效应" class="headerlink" title="ZK的惊群效应"></a><strong>ZK的惊群效应</strong></h4><p>答：是指在利用临时节点做分布式锁时，如果删除lock节点，会通知其余的客户端，都去创建节点申请锁，解决办法是只监听上一个节点的操作事件</p>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高并发和高可用</title>
      <link href="/2019/12/12/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2019/12/12/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul><li>keepalived是Linux下面实现VRRP备份路由的高可靠性运行件，它是基于VRRP全称 Virtual Router Redundancy Protocol，即 虚拟路由冗余协议，此协议将多个路由器组成路由器组，这个组里面有master和多个backup，通过虚拟ip对外提供服务，master会发组播消息，当backup收不到就根据vrrp优先级选出一个master</li></ul><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a><strong>高并发</strong></h4><p>高并发常用的指标，响应时间(Response Time RT)，吞吐量(Throughout)，每秒查询量(Query per Seconds QPS)，并发用户数等，提高并发的方法论主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）</p><ul><li>垂直扩展 单台机器的处理毕竟是有限的<ul><li>增强单机硬件性能，增加CPU、内存、磁盘换SSD、升级网卡带宽等<ul><li>提升单机架构性能，增加cache减少IO，使用异步增加单服务吞吐量，使用无锁数据结构来减少响应时间</li></ul></li></ul></li><li>水平扩展<ul><li>反向代理层：增加nginx机器数量</li><li>服务层：增加服务部署机器</li><li>数据层：按业务进行分库分表</li></ul></li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h4><p>高可用HA（High Availability），通过设计减少系统不能提供服务的时间，一是要屏蔽单点问题，而是要出现故障能自动切换或修复，所以HA的套路就是 冗余+自动故障转移。主要是每层之间的高可用：</p><ul><li>客户端层：浏览器和app，这层主要是终端代码优化</li><li>反向代理层：nginx+keepalived+virtual IP，冗余nginx，通过keepalive存活探测，通过在keepalive配置文件中添加虚拟ip，实现nginx的自动故障转移，还能配置发送邮件通知</li><li>服务层：通过服务冗余，nginx能探测到哪个服务挂了，流量自动迁移</li><li>数据-缓存层：如redis，支持主从同步，通过哨兵做存活性检测</li><li>数据-数据库层：数据库的读写分离，读库高可用通过连接池能够探测，写库高可用通过keepalived+virtual IP实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-锁</title>
      <link href="/2019/12/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%94%81/"/>
      <url>/2019/12/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h4 id="synchronize和reentrantlock区别"><a href="#synchronize和reentrantlock区别" class="headerlink" title="synchronize和reentrantlock区别"></a><strong>synchronize和reentrantlock区别</strong></h4><ul><li>sync是java关键字，rlock是一个类</li><li>sync等待不可中断，线程不会因为长时间获取不到锁，而中断获取，转而去做其他事，rlock可以</li><li>sync是非公平锁，锁释放后任何一个等待锁的线程都有可能获取锁，rlock默认是非公平锁，通过参数可以初始化为公平锁，通过FIFO队列来实现</li><li>sync只支持绑定一个条件，如果要和多余一个条件关联，不得不额外添加一个锁，rlock可以同时绑定多个Condition对象，只需多次调用newCondition即可</li><li>性能上现在两个基本持平，虚拟机更偏向sync</li></ul><h4 id="数据库死锁"><a href="#数据库死锁" class="headerlink" title="数据库死锁"></a><strong>数据库死锁</strong></h4><ul><li>长事务导致undo等资源的争抢，占用binlog的提交队列导致后继事务处于commit阶段无法提交，即便强制kill也会引发长时间的rollback操作</li><li>成因主要是长事务和低性能sql，因为他们慢导致资源无法提交，而形成环路等待</li></ul><h4 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a><strong>CAS的ABA问题</strong></h4><ul><li>CAS是乐观锁，操作时比较传入的旧值与当前值是否相等，相等才进行替换，仅针对值比较，就可能出现1A2B3A的情况</li><li>解决办法：跟数据库乐观锁一样，加版本号解决，每次操作版本号+1，比较时同时比较数值和版本号</li></ul><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h4><ul><li>ReadWriteLock同Lock一样也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个是只读的锁，一个是写锁</li><li>将对一个对象的访问分为读和写，读的时候获取的是读锁，写的时候获取的是写锁，二者不能同时持有</li><li>可重入，写锁可降级为读锁</li><li>适合读多写少的场景</li><li>其原理和reentrantlock差不多，无非是划分为两个锁，同时在内部通过ThreadLocal维护当前的读写状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-数据结构</title>
      <link href="/2019/12/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/12/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h4 id="hashmap为什么是线程不安全的"><a href="#hashmap为什么是线程不安全的" class="headerlink" title="hashmap为什么是线程不安全的"></a><strong>hashmap为什么是线程不安全的</strong></h4><p>答：第一、并发的时候，触发扩容，导致读取的时候<br>第二、hashmap在扩容时，会触发resize，如果同时有线程在操作，可能会出现在桶上形成环形链表，导致后面get的时候，出现死循环。如：线程1和线程2都在插入，都往里面插入数据A和B，线程1 A.next=B,线程2 B.next=A，形成环形链表</p><h4 id="hashmap，hashtable，linkedhashmap区别"><a href="#hashmap，hashtable，linkedhashmap区别" class="headerlink" title="hashmap，hashtable，linkedhashmap区别"></a><strong>hashmap，hashtable，linkedhashmap区别</strong></h4><p>答：</p><ul><li>hashtable是数组+链表，无论key还是value，都不能为空，通过在方法上加synchronize关键字，实现线程安全，初始size=11，扩容newsize=oldsize×2+1，计算index方法：index = (hash &amp; 0x7FFFFFFF) % tab.length</li><li>hashmap是数组+链表，初始capacity=16(1&lt;&lt;4),最大是2<sup>31</sup>，默认负载因子是0.75f</li><li>linkedHashMap是在hashmap的基础上，将节点加入到双向链表中，分两种顺序：<ul><li>插入顺序：按照put时的顺序存储 </li><li>访问顺序：读取一个entry，就将整个entry移动到队尾<br><a href="https://www.cnblogs.com/heyonggang/p/9112731.html" target="_blank" rel="noopener">三者区别</a></li></ul></li></ul><h4 id="TreeMap怎么实现的"><a href="#TreeMap怎么实现的" class="headerlink" title="TreeMap怎么实现的"></a><strong>TreeMap怎么实现的</strong></h4><p>答：通过红黑树实现，不允许key为null，根据红黑树特性实现有序性</p><h4 id="为什么hashmap初始化capacity-16和0-75"><a href="#为什么hashmap初始化capacity-16和0-75" class="headerlink" title="为什么hashmap初始化capacity=16和0.75"></a><strong>为什么hashmap初始化capacity=16和0.75</strong></h4><p>答：16是2的4次方，因为hash算法是跟cap-1进行位运算，这样bucket就只跟低位的值有关，可以减少hash碰撞，0.75是因为采用随机hash，节点出现遵循泊松分布，用0.75作为负载因子，每个碰撞位置的链表长度超过8个是几乎不可能的</p><h4 id="为什么1-8hashmap要用红黑树"><a href="#为什么1-8hashmap要用红黑树" class="headerlink" title="为什么1.8hashmap要用红黑树"></a><strong>为什么1.8hashmap要用红黑树</strong></h4><p>答：链表的查询时间复杂度是O(n)，而红黑树(平衡二叉树)查询是O(logn)，个数少时，插入删除成本高，用链表；个数多时，查询成本高，用红黑树；在负载因子为0.75的情况下，桶里面元素的个数为8的概率小于百万分之一，故&gt;=8时才转换成红黑树</p><h4 id="concurrentHashMap1-8的优化有哪些"><a href="#concurrentHashMap1-8的优化有哪些" class="headerlink" title="concurrentHashMap1.8的优化有哪些"></a><strong>concurrentHashMap1.8的优化有哪些</strong></h4><p>答：取消segment，采用table数组来实现行锁；链表长度&gt;=8引入红黑树；</p><h4 id="concurrentHashMap1-8为什么取消segment-rlock"><a href="#concurrentHashMap1-8为什么取消segment-rlock" class="headerlink" title="concurrentHashMap1.8为什么取消segment+rlock"></a><strong>concurrentHashMap1.8为什么取消segment+rlock</strong></h4><p>答：一是减少内存消耗，使用rlock，需要继承AQS来获取同步支持，但并不是每个node都需要同步，只有链表的头结点（红黑树的根节点），无疑是浪费内存；而是sync优化以后，性能提高了，同时rlock是api级别的，而sync是可以通过jdk的升级且不更改代码的情况下，获得性能上的提升</p><h4 id="set是如何保证元素不重复的"><a href="#set是如何保证元素不重复的" class="headerlink" title="set是如何保证元素不重复的"></a><strong>set是如何保证元素不重复的</strong></h4><p>答：以hashset为例，就是将要存储的值，作为key存储到hashmap中，因为hashmap的key是不会重复的</p>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring专题</title>
      <link href="/2019/12/11/Spring%E4%B8%93%E9%A2%98/"/>
      <url>/2019/12/11/Spring%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a><strong>IoC</strong></h4><p>Inversion of Control 控制反转，其中最常见的方式是两种</p><ul><li>依赖查找(Dependency Lookup，简称DL，已经被抛弃，因为他需要用户自己去使用API进行查找资源和组装对象，有侵入性)</li><li>依赖注入(Dependency Injection，简称DI)，可以通过setter，构造函数进行注入</li></ul><h4 id="spring的ioc"><a href="#spring的ioc" class="headerlink" title="spring的ioc"></a><strong>spring的ioc</strong></h4><p>最重要的就是容器技术，容器管理着bean的生命周期，控制bean的依赖注入，从xml的配置上说即ref标签，对应Spring的RuntimeBeanReference对象，Spring实现了两种容器</p><ul><li>BeanFactory 低级容器，对象工厂，就是个map，key为beanName，value为bean实例，提供 getBean(),getType(),isSingleton(),containsBean()等</li><li>ApplicationContext 高级容器，核心是refresh()，初始化工厂，注册监听器，设置环境变量，修改bean属性等<br><img src="/images/pasted-49.png" alt="refresh"><br><img src="/images/pasted-25.png" alt="Spring容器"><br>参考<a href="https://www.jianshu.com/p/17b66e6390fd" target="_blank" rel="noopener">面试被问烂的 Spring IOC</a></li></ul><h4 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a><strong>Spring bean的生命周期</strong></h4><ul><li>通过构造器或工厂方法创建bean实例</li><li>为bean的属性设置值和对其他bean的引用</li><li>将bean实例传递给bean后置处理器的postProcessBeforeInitialization()方法</li><li>调用bean的初始化方法，如果bean实现了如BeanNameAware，ApplicationContextAware的，会调用相应的实现方法</li><li>将bean实例传递给bean后置处理器的postProcessAfterInitialization()方法</li><li>此时bean已经准备，可以被应用使用，并驻留在应用上下文中，直到应用上下文被销毁</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用</li></ul><h4 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a><strong>循环依赖问题</strong></h4><p>bean是先通过构造函数初始化，再进行属性赋值如setter，所以构造函数执行完，部分属性已经设置成功，没办法侵入，而setter方法是在初始化后，可以在中间插入功能去解决问题</p><ul><li>①a的构造方法中依赖b的实例对象，b的构造方法中依赖a的实例对象</li><li>②a的构造方法中依赖b的实例兑现，b的某个field或者setter依赖a的实例对象</li><li>③a的某个field或者setter依赖b的实例对象，b的某个field或者setter需要a的实例对象<br>Spring对于1没解决，2解决了一半，3完全解决<br>Spring循环依赖的理论依据是基于java的引用传递，Spring的单例初始化可以分为三步</li><li>createBeanInstance，通过调用对应的构造方法构造对象</li><li>populateBean，填充属性，这步对Spring xml中指定的property进行populate</li><li>initializeBean，调用Spring xml中指定的init方法，或者AfterPropertiesSet方法<br>发生循环依赖的集中在第一步和第二步，对于单例对象，在Spring的整个容器生命周期中，有且仅有一个对象，这些对象都存在cache中，通过DefaultSingletonBeanRegistry中的三级缓存的方式解决了循环依赖<br>AbstractBeanFactory为bean创建的入口<br>在DefaultSingletonBeanRegistry使用三级缓存</li><li>一级缓存 singletonObjects 初始化完整的单例bean</li><li>二级缓存 earlySingletonObjects 提前暴光的单例对象的Cache</li><li>三级缓存 singletonFactories ObjectFactory工厂bean缓存, 存储实例化后的bean Factory<br>还可以通过@Lazy的方式，延迟加载，解决循环依赖</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h4><p>面向切面编程，可以说是对OOP的补充和完善，OOP是用以模拟公共行为的一个集合，允许你定义从上到下，但是不能从左到右，当我们需要为分散对象引入公共行为时，OOP则无能为力，例如日志功能，日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。<br><strong>实现AOP的技术，主要有两大类</strong></p><ul><li>动态代理：以截取消息的方式，对原有消息进行装饰，以取代原有对象的执行</li><li>静态织入：引入特定的语法创建aspect，使编译器在编译期织入aspect代码，如：AspectJ，它有自己的编译器ajc，在编译器将代码织入到class文件中</li></ul><p><strong>使用场景</strong><br>日志、权限、事务、追踪、监控、错误处理、调试等<br><strong>主要内容</strong></p><ul><li>Advice </li><li>Pointcut 切入点  类，方法，可正则匹配</li><li>Advice 通知  around before after throws</li></ul><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a><strong>Spring事务</strong></h4><ul><li>spring事务的本质就是对数据库事务的支持，维护着mysql连接，控制着commit和rollback操作，提供 编程式事务(TransactionTemplate) 和 声明式事务(AOP @Transactional)</li></ul><h4 id="java注解是怎么实现的"><a href="#java注解是怎么实现的" class="headerlink" title="java注解是怎么实现的"></a><strong>java注解是怎么实现的</strong></h4><p>注解本质是一个继承了Annoatation的特殊接口，其具体实现类是java运行时生成的动态代理类，而我们通过反射获取注解时，返回的是那个代理对象$Proxy1，通过代理对象调用自定义注解方法，会最终调用AnnotationInvocationHandler的invoke方法，该方法会从memberValues这个map中索引对应的值<br>参考<a href="https://www.cnblogs.com/yuarvin/p/10848928.html" target="_blank" rel="noopener"><strong>java注解原理</strong></a></p><ul><li>@Target 注解用于什么地方，包、类、方法、参数等</li><li>@Retention 注解运行环境 <ul><li>源码SOURCE</li><li>编译类CLASS 在编译时扫描和处理注解，生成.java文件，依赖于apt(annotation processing tool注解处理器），主要用在安卓开发中</li><li>运行时RUNTIME 就是在运行时运用反射，动态获取对象、属性、方法等</li></ul></li><li>@Documented 生成说明文档，添加类的解释</li><li>@Inherited 允许子类继承父类中的注解</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库事务</title>
      <link href="/2019/12/10/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/12/10/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h4><ul><li>MyISAM默认是表级锁，不支持行级锁</li><li>InnoDB默认是行级锁，也支持表级锁，在使用索引时是行级锁，不使用索引时是表级锁</li><li>共享锁（读锁），当前事务对某行或某张表上了共享锁之后，其他事务只能上共享锁，不支持上排它锁，在语句中使用lock in share mode加共享锁</li><li>排它锁（写锁），当前事务对某行或某张表加上了排它锁之后，其他事务读写都不被允许，使用for update加排它锁</li><li>乐观锁，总是假设最好的情况，认为竞争总不存在，因此每次更新时，比较数据是否已经被更新，可以通过CAS和版本号进行比较</li><li>悲观锁，总是假设最坏的情况，认为竞争总是存在，因此每次都会上锁，其他线程等待释放锁</li><li>间隙锁，当使用范围条件来操作数据时，会对范围内查得到的数据加锁，同时也会对范围内查不到的数据加锁，如：where后面是1到5，数据库中只有123的记录，那么45的也会被加锁，如果插入45的数据，就会报错</li></ul><h4 id="数据库日志"><a href="#数据库日志" class="headerlink" title="数据库日志"></a><strong>数据库日志</strong></h4><ul><li>redo log：修改数据时，从磁盘读取到buffer pool进行修改，如果修改时出现故障，那么数据就会丢失，所以用redo log来记录buffer pool修改记录</li><li>undo log：记录的是对buffer pool操作之前的数据，以保证事务回滚</li></ul><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a><strong>事务特性</strong></h4><ul><li>原子性(Atomicity)：事务是最小单位，不可再分割，要么全部执行，要么全部不执行，如果执行失败则回滚，执行成功则提交。</li><li>一致性(Consistency)：</li><li>隔离性(Isolation)：不同事务之间互不影响</li><li>持久性(Durability)：事务一旦提交，它对数据库的改变是永久的，接下来的操作和故障不会对此产生影响</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h4><ul><li>读未提交(Read-Uncommitted) 能读取到未提交的事务数据</li><li>读已提交(Read-Committed) 能读取到已提交的事务数据</li><li>可重复读(Repeatable-Read) innodb默认级别，该sql第一次读取到时，就将这些记录加行锁，但是没办法锁住insert，造成读的时候，新插入的数据，还能查出来</li><li>串行化(Serializable) 读用读锁(共享锁)，写用写锁(排它锁)，读锁和写锁互斥</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>MyISAM：频繁执行全表count，查询很频繁，增删改很少，不需要事务</li><li>InnoDB：增删改查都很频繁，需要事务</li></ul><h4 id="行级锁一定比表级锁优吗"><a href="#行级锁一定比表级锁优吗" class="headerlink" title="行级锁一定比表级锁优吗"></a><strong>行级锁一定比表级锁优吗</strong></h4><p>答：不一定，锁的粒度越细，其消耗的资源代价越高，行级锁需要扫描到某行，再上锁，资源代价大</p><h4 id="mysql并发控制"><a href="#mysql并发控制" class="headerlink" title="mysql并发控制"></a><strong>mysql并发控制</strong></h4><ul><li>一个是MVCC：Multi-Version Concurrency Control多版本并发控制，实现方式就是乐观锁，但是mysql写的时候会加排它锁，所以mvcc实际只是实现了读的非阻塞而已<ul><li>每条记录都有个版本，每条数据更新时更新该版本<ul><li>修改时copy出当前版本，随意修改</li></ul></li><li>提交时，与原记录比较版本号，如果成功，覆盖原记录，失败，就放弃copy(rollback)</li></ul></li></ul><p><strong>innodb的mvcc实现，每行额外保存两个隐藏的列，创建版本号和删除版本号，事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较</strong></p><ul><li>一个是两阶段锁协议：<ul><li>所有事务必须分两阶段对数据进行加锁和解锁，在对数据进行查询、修改之前，事务首先要获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得任何其他封锁</li><li>对于mysql就是：<ul><li>扩展阶段：事务开始后，commit之前，获取锁</li><li>收缩阶段：commit之后，释放锁</li></ul></li></ul></li></ul><p><strong>但是两阶段锁不要求事务必须一次将所有需要使用的锁加锁，并且加锁阶段没有顺序要求，所以这种并发控制会产生死锁</strong></p><h4 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a><strong>死锁处理</strong></h4><ul><li>通过设置超时时间，innodb_lock_wait_timeout，这个参数设置太长，线上服务等待太久，太短(1s)，会误伤有些事务确实是锁等待</li><li>通过设置 innodb_deadlock_detect = on，发起死锁检测，发现死锁后，主动回滚死锁链表中的某一事务，让其他事务得以继续进行，其原理是：<strong>构建一个以事务为顶点，锁为边的有向图，如果图中有环就是存在死锁</strong></li></ul><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a><strong>避免死锁</strong></h4><p><strong>mysql通过SHOW ENGINE INNODB STATUS;来查看死锁日志</strong></p><ul><li>使用事务，不要锁表</li><li>保证没有长事务</li><li>修改多个表或多个行时，保持顺序一致</li><li>合理创建索引，可以使创建的锁更少</li><li>业务允许的话，尝试降低隔离级别</li><li>最好是在业务层代码进行优化，控制好并发，减少到数据库使用锁的场景，比如一个账户设计成多个账本，每次选其中一个账本进行操作，将行锁分开</li></ul><p>参考：<a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">mysql中MVCC原理及讲解</a><br><a href="https://blog.csdn.net/weixin_38118016/article/details/90271468" target="_blank" rel="noopener">深入理解锁知识</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC和HTTP</title>
      <link href="/2019/12/09/RPC%E5%92%8CHTTP/"/>
      <url>/2019/12/09/RPC%E5%92%8CHTTP/</url>
      
        <content type="html"><![CDATA[<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><strong>RPC</strong></h4><p>RPC(Remote Producer Call Protocol 远端过程调用)，它是网络服务协议，与操作系统和语言无关，通过网络服务协议向远程主机发送请求，只要客户端和服务端协调好协议即可</p><h4 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a><strong>RMI</strong></h4><p>RMI(Remote Method Invocation)是专为Java环境设计的远程方法调用机制，可以说是RPC的java实现方式，RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写，在RMI中对象是通过序列化方式进行编码传输的<br><strong>能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端java虚拟机中的对象上的方法</strong></p><p>JVM之间通讯时，只是传递了一个远程对象的存根stub，相当于一个引用或者代理，所以要调用远程方法，就需要一个远程对象stub，jdk提供一个RMI注册表来实现，默认监听在1099端口上，将远程服务的stub存储在注册表中</p><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/131" target="_blank" rel="noopener">深入理解JNDI注入与Java反序列化漏洞利用</a></p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><strong>HTTP</strong></h4><p>HTTP(HyperText Transfer Protocol 超文本传输协议)</p><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a><strong>两者区别</strong></h4><p>http请求是使用具有标准语义的通用的接口定向到资源的，这些语义能够被中间件和提供服务的来源机器进行解释，是基于网络的，而rpc的机制是根据语言的API来定义的，而不是基于网络的应用来定义的</p><h4 id="两者优缺点"><a href="#两者优缺点" class="headerlink" title="两者优缺点"></a><strong>两者优缺点</strong></h4><ul><li>传输协议<ul><li>RPC：可以基于TCP协议，也可以基于HTTP协议</li><li>HTTP：基于HTTP协议</li></ul></li><li>传输效率：<ul><li>RPC：使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议</li><li>HTTP：如果使用http1.1，报文中有很多无用的内容   </li></ul></li><li>性能消耗<ul><li>RPC：可以基于thrift实现高效的二进制传输</li><li>HTTP：大部分通过json实现，字节大小和序列化都比thrift更耗性能</li></ul></li><li>负载均衡<ul><li>RPC：基本都自带lb策略</li><li>HTTP：需要配置nginx、haproxy来实现</li></ul></li><li>服务通知<ul><li>RPC：能做到自动通知，不影响上游</li><li>HTTP：需要实现通知，ng配置<br>总结：RPC用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便，HTTP用于对外的异构环境，浏览器，app接口，第三方调用等</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hashCode和equals</title>
      <link href="/2019/12/09/hashCode%E5%92%8Cequals/"/>
      <url>/2019/12/09/hashCode%E5%92%8Cequals/</url>
      
        <content type="html"><![CDATA[<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><strong>equals方法</strong></h4><p>equals设计时的几个原则</p><ul><li>自反性：a.equals(a) 一定返回true</li><li>对null：a.equals(null) 一定返回false</li><li>对称性：a.equals(b)和b.equals(a)返回结果一致</li><li>传递性：a.equals(b),b.equals(c),那么a.equals(c)一定返回true</li><li>一致性：两个对象状态改变，不会影响equals的决策结果</li></ul><h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><strong>hashCode方法</strong></h4><p>返回对象求得的散列码，int型，对象的散列码是为了更好的支持基于hash的集合类</p><ul><li>在某个运行期间，如果字段的改变，不影响hashcode计算，那么在此期间无论调用多少次，都返回同一个散列码</li><li>两个对象equals返回true，那他们的hashCode值一定相等；允许对象的equals为false，但是hashCode返回值相同</li></ul><h4 id="为什么重写equals后必须重写hashcode"><a href="#为什么重写equals后必须重写hashcode" class="headerlink" title="为什么重写equals后必须重写hashcode"></a><strong>为什么重写equals后必须重写hashcode</strong></h4><p>有一条原则：两个对象equals返回true，那他们的hashCode值一定相等，如果重写了equals不重写hashCode，就有可能导致hashMap等集合中key，出现不确定性</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis合集</title>
      <link href="/2019/12/03/Redis%E5%90%88%E9%9B%86/"/>
      <url>/2019/12/03/Redis%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="Redis如何能够高并发"><a href="#Redis如何能够高并发" class="headerlink" title="Redis如何能够高并发"></a><strong>Redis如何能够高并发</strong></h4><ul><li>绝大部分的请求，纯粹是是内存操作，非常快</li><li>采用单线程技术，避免了不必要的上下文切换和竞争条件</li><li>采用多路复用IO技术，非阻塞IO，可以让单线程高效的护理多个请求</li><li>服务端对于收到的客户端请求，是采用序列化执行方式，类似mysql事务序列化级别，保证原子性</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h4><p>这些类型都是针对value而定<br>String：value是字符串，命令：get set del incr decr等<br>hash：value是比较类似数据库中表的一条记录，hset hget hdel hexists等<br>list：value是list，命令：lpush(头插) lpop rpush(尾插) rpop lrange，结构：ziplist、linkedlist、quicklist<br>set：value是无序集合，元素不重复，命令：sadd srem spop等<br>zset：value是有序集合，元素不重复并且有序，命令：zadd zrem zrange zrank等</p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h4><ul><li>rdb模式，通过配置redis在n秒内如果超过m个key被修改则执行一次RDB操作，将数据集快照写入磁盘，fork一个子进程去将快照dump到磁盘，生成临时文件，dump完后覆盖历史备份文件</li><li>aof模式，以追加日志的方式存储修改、删除记录，类似mysql的binlog</li></ul><p><strong>两者区别</strong></p><ul><li>rdb只会生成一个文件，对于备份到其他介质很方便，可以立马恢复到某一天的数据，生成的文件小<ul><li>如果在备份的过程中宕机，没来得及写入磁盘的数据都会丢失</li><li>如果数据集过大，还会导致整个服务停止几百毫秒甚至1秒钟</li></ul></li><li>aof记录的是操作历史，文件大，能设置三种持久化方式，每次数据修改同步一次，每秒钟同步一次(默认)，不同步，如果日志过大，redis会启动rewrite模式，即除了将修改记录写入老的文件，同时还会新生成文件，记录这期间的有哪些修改被执行，防止写入失败导致数据丢失<ul><li>文件大，恢复比rdb慢</li><li>运行效率比rdb低</li></ul></li></ul><p><strong>两者选择</strong></p><ul><li>如果要高可用，保证数据完整性和一致性，用aof</li><li>如果要高性能，不在乎部分数据丢失，用rdb</li></ul><h4 id="常见性能和解决方案"><a href="#常见性能和解决方案" class="headerlink" title="常见性能和解决方案"></a><strong>常见性能和解决方案</strong></h4><p>redis常见性能问题和解决方案：</p><ul><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度)</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li></ul><h4 id="读写分离模型"><a href="#读写分离模型" class="headerlink" title="读写分离模型"></a><strong>读写分离模型</strong></h4><ul><li>通过主从模式，读的性能线性增长，为了避免主节点单点故障，可采用两台主做双机热备</li><li>读写分离的缺点在于，不管主还是从，都需要保存全部的数据，集群的扩展能力，还是局限于单节点的存储能力</li></ul><h4 id="数据分片模型"><a href="#数据分片模型" class="headerlink" title="数据分片模型"></a><strong>数据分片模型</strong></h4><ul><li>为了解决读写分离模型的缺陷，可以将数据分片，将每个节点看成独立的Master，然后通过业务实现分片</li><li>可以将每个master设计成由一个master和多个slave组成的模型</li></ul><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a><strong>哨兵</strong></h4><ul><li><p>sentinel哨兵一个分布式系统，你可以开启多个哨兵进程，这些进程使用流言协议来接收关于Master是否下线，并通过投票协议来决定是否故障迁移和选择哪个Slave作为新Master<br>实现原理：</p></li><li><p>sentinel每X秒钟一次的向它所知的Master、Slave发送ping命令（心跳监测）</p></li><li><p>如果一个节点ping返回的时长超过指定值，就标记其为主观下线</p></li><li><p>如果一个Master标记成主观下线，那其他的哨兵会去确认Master是否下线</p></li><li><p>当指定配置数量的哨兵在指定时间范围内，确认Master已下线，则Master标记为客观下线</p></li><li><p>一般情况下，哨兵每10s向所有M S发送info命令</p></li><li><p>当M被标记为客观下线，则每1s向M下所有的S发送info命令</p></li><li><p>通过选举算法raft去选出一个slave来晋升master</p><p>架构细节:<br>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.<br>(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.<br>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<br>(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</p></li></ul><p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h4><p>答：一般缓存设计思路是：缓存中查不到，就去数据库查。假如某个key，缓存中一直没有，那每次查都是要去请求数据库，可能数据库也没这些数据，但是数据库资源已经被占用，这就是缓存击穿<br>解决办法：①对于这些没有数据的key，也缓存起来，设置几秒钟失效，减少数据库压力<br>②使用boomfilter存储key的集合<br>如果未命中的key多重复率低，使用方案②，防止缓存被占满<br>如果未命中的key少重复率高，使用方案①</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p>答：如果是失效时间问题，比如好多都设置在0点，但是当系统中所有的缓存，都在0点一起失效了，这时候业务来请求时，就会造成大批量去数据库查询，然后新增到缓存，导致缓存服务器宕机<br>如果缓存查询量过大，则可以采用redis主从+哨兵，配合限流(直接拒绝)+降级(返回部分数据)，防止db被打满，开启持久化，便于恢复</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h4><p>答：是指某些key非常热点，导致在失效的那一刻，大批量的请求查询直接请求到了数据库<br>解决方案：提前评估哪些是可能会成为爆款，直接设置永不过期</p><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a><strong>缓存更新</strong></h4><p>答：更新缓存这种有并发请求时，容易造成数据不一致，就不考虑了，主要集中在以下两种方式</p><ul><li>先删除缓存，再更新数据库：延时双删策略，先删除缓存，再更新数据库，休眠1s(睡眠时间修改为在主从同步的延时时间基础上，加几百ms)等待缓存主从同步完成，再删除缓存，这步可以做异步，通过消息队列去删，还能实现失败重试</li><li>先更新数据库，再删除缓存(推荐)：Cache-Aside pattern中也推荐这种方式，先更新数据库，然后再删除缓存，读请求时，从数据库加载缓存，存在的弊病是，数据库操作成功，缓存删除失败，可以通过消息队列去删，失败的发起重试</li></ul><h4 id="缓存热点、缓存预热"><a href="#缓存热点、缓存预热" class="headerlink" title="缓存热点、缓存预热"></a><strong>缓存热点、缓存预热</strong></h4><p>答：某些key可能突然访问量很大，导致达到系统瓶颈，甚至拖垮redis集群，如何解决呢</p><ul><li>热点发现：要探测出哪些是热点key，一是根据历史数据和当前业务场景提前预测，二是提前演练，通过自动化测试去探测，三是通过实时统计，用定时任务统计，流计算去统计都可以</li><li>热点通知：通过将发现的key写入到zknode中，让缓存系统去监听这个节点的变化</li><li>热点处理：如何更新这些热点key，这就涉及到CAP取舍问题了，<ul><li>如果是对数据一致性要求很高的，比如支付系统，那我们采取事务控制，可能延时会大点，数据不会出现不一致，比如采用分布式锁，只允许一个去查数据库更新缓存</li><li>对可用性要求高，能容忍短时间的数据不一致，那我们可以采取全量同步+增量更新的方式，前期将key全量刷入缓存系统中，后面通过数据库binlog进行增量更新，还可以结合本地内存缓存</li></ul></li></ul><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a><strong>多级缓存</strong></h4><p>答：基本上有三层</p><ul><li>应用层nginx代理缓存：通过proxy_cache设置，nginx把key存在内存里，value还是存储在磁盘中，所以它不适合高并发场景，但是可以缓存一些对时效性，一致性要求不高的数据，比如大文件的传输</li><li>分布式redis缓存：通用的方案，当缓存命中时，要更新应用层本地缓存</li><li>应用层本地堆内缓存：如果redis中没有，则到应用层本地缓存查询，还没有，再去数据库查询，查完后要回写本地缓存和redis缓存</li></ul><h4 id="缓存过期"><a href="#缓存过期" class="headerlink" title="缓存过期"></a><strong>缓存过期</strong></h4><p>过期策略：</p><ul><li>定期删除：每隔一段时间，从过期集合中删除key，redis.conf文件中 hz 10 默认是每秒执行10次，随机抽取一些key检查是否过期，过期删除，并不是全部</li><li>惰性删除：key过期不删除，每次通过key获取值的时候，去检查是否过期，若过期则删除，返回null<br>定期删除会占用cpu，要根据系统情况来设置时间间隔，惰性删除如果长期没有获取key，就会发生内存泄露，一般是两种结合使用，优势互补<br>这两种方式只是确保最终会删除，但是期间还是有大量过期的key存在，所以当内存占用过高时，淘汰方案有：</li><li>FIFO(First In First out)：先进先淘汰</li><li>LFU(Least Frequently used)：使用频率最低</li><li>LRU(Least Recently used)：最近最少使用<br><img src="/images/pasted-50.png" alt="redis过期策略"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/12/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/12/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="排序汇总"><a href="#排序汇总" class="headerlink" title="排序汇总"></a><strong>排序汇总</strong></h4><p><img src="/images/pasted-22.png" alt="排序算法"></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h4><p>从当前元素开始，向后比较相邻的元素，取大的值继续跟后面的比较，直到最大的值排在尾部，后续的继续按照这种方式，重复操作</p><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a><strong>快排</strong></h4><p>取数组中的一个值，作为一个基准，以基准值为界，左边的都小于基准值，右边的都大于基准值，然后左右两边分别进行刚才的操作</p><ul><li>实现分界，以第一个数a为基准，两个指针i，j，i指向最左侧，j指向最右侧，j开始从后向前移动，直到遇到&lt;a的值暂停，然后i开始向右移动，找到&gt;a的值暂停，交换i，j对应的数据，然后j继续移动，同样操作，当某一刻i和j碰撞时，即扫描结束，交换a和当前值</li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h4><p>将数据先组成堆，然后通过比较子节点和父节点的大小，进行替换</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h4><p>遍历数据，嵌套for循环，每取一个数据，跟后面的数据进行比较，每一轮将最小值与当前值，进行替换，重复此操作</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h4><p>从第一个数据开始，取出下一个元素，跟前面已经排序好的数据，从后往前比较，插入到相应的位置</p><p>参考：<br><a href="https://blog.csdn.net/shujian_tianya/article/details/80963783" target="_blank" rel="noopener">算法小结</a><br><a href="https://blog.csdn.net/weixin_44811417/article/details/90748011" target="_blank" rel="noopener">gif排序算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试话术</title>
      <link href="/2019/12/03/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/"/>
      <url>/2019/12/03/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="尽可能展示自己"><a href="#尽可能展示自己" class="headerlink" title="尽可能展示自己"></a><strong>尽可能展示自己</strong></h4><p>将自己知道的尽可能多的展示给面试官，但一定要是自己熟悉的，不熟的不要提，如面试官问map的原理，map是接口，主要实现类hashmap，并发map等，还要聊聊map的底层数据结构，跟hashtable的对比</p><h4 id="日常工作规范"><a href="#日常工作规范" class="headerlink" title="日常工作规范"></a><strong>日常工作规范</strong></h4><ul><li>遵循alibaba开发规范代码检查</li><li>异常类的设计</li><li>日志的设计</li><li>代码分层设计</li><li>设计模式的运用</li><li>常见错误排查的分享</li></ul><h4 id="找一个项目进行精细化耕作"><a href="#找一个项目进行精细化耕作" class="headerlink" title="找一个项目进行精细化耕作"></a><strong>找一个项目进行精细化耕作</strong></h4><p>找一个自己认为代表性的项目，将整个项目的各个方面进行复盘，多给自己提些问题，如数据怎么流转，怎么保证一致性，三方挂了怎么办</p><h4 id="前台后台都做么"><a href="#前台后台都做么" class="headerlink" title="前台后台都做么"></a><strong>前台后台都做么</strong></h4><p>这一般是我的第一个问题,超过90%的人会回答:”都做,后台多一点,前台少一点“，这不是我想要的答案,鬼都知道程序员都要多少涉及一下前台,后台更不用说了，碰到过一个聪明人,他是这么回答的: 前台js写的比较熟练,html的框架模板也能搭建的非常整齐美观,只是特效能力比较差<br>这个问题我不想过多讨论,加分但不减分</p><h4 id="什么是事务-为何用事务"><a href="#什么是事务-为何用事务" class="headerlink" title="什么是事务,为何用事务"></a><strong>什么是事务,为何用事务</strong></h4><p>大部分面试者,就会举各种各样的例子(比如银行存钱,这个最多)来说明这个问题,其实他们都理解，但这不是我想要的答案,我期望的答案只有一句:”保证数据的一致性和完整性” ,可惜只有5%左右的人答出来了<br>这个问题可以大概了解出面试者的分析能力,以及语言总结能力,还有他们对这个玩意的理解程度<br>答不出减分,举例子不加分</p>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一致性hash</title>
      <link href="/2019/12/02/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>/2019/12/02/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      
        <content type="html"><![CDATA[<h4 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a><strong>问题由来</strong></h4><ul><li>图片存储到多台服务器，数据存储分库分表(mysql、redis)</li><li>如何保证数据均匀分布</li><li>如何保证某些机器不可用，仍不影响集群数据，数据迁移工作少</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ul><li>通过hash环，还是取模，只不过是hash(n)%2<sup>32</sup>-1</li><li>当环中有n个节点时，每个key经过上面的hash，肯定落在0~2<sup>32</sup>-1范围内</li><li>顺时针方向，取离的最近的一台服务器作为存储</li><li>问题：可能会出现大部分机器落在hash环的某半边，导致数据大部分落在首尾的节点上</li></ul><h4 id="改进版解决方案"><a href="#改进版解决方案" class="headerlink" title="改进版解决方案"></a><strong>改进版解决方案</strong></h4><ul><li>通过在hash环中，放入虚拟节点</li><li>这些虚拟节点，执行具体的节点，这样就让数据很均匀的分布开</li><li>容错性：当一台机器宕机后，只影响当前节点到前一个节点之间的数据</li><li>可扩展性：增加节点后，只影响加入节点和前一个节点之间的数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AQS系列</title>
      <link href="/2019/12/01/AQS%E7%B3%BB%E5%88%97/"/>
      <url>/2019/12/01/AQS%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="unsafe类"><a href="#unsafe类" class="headerlink" title="unsafe类"></a><strong>unsafe类</strong></h4><p>AQS通过LockSupport类用到unfase类中的两个方法，C++代码底层通过_counter来实现</p><ul><li>park：线程调用park，相当于等待许可</li><li>unpark：线程调用unpark，相当于颁发许可</li></ul><p><strong>unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行，也就是不会阻塞。<br>而如果线程A处于等待许可状态，再次调用park，则会永远等待下去，调用unpark也无法唤醒</strong></p><h4 id="独占式和共享式"><a href="#独占式和共享式" class="headerlink" title="独占式和共享式"></a><strong>独占式和共享式</strong></h4><ul><li>独占式：就是同一时间只有一个线程能获取资源，如ReentrantLock</li><li>共享式：就是同一时间可以多个线程能获取资源，如Semaphore，countDownLatch</li></ul><p><strong>AQS实现独占式，就是一个节点释放锁，只会唤醒后继节点，不带share的方法；<br>实现共享式，则会向后传播，重复唤醒后继节点，带share的方法</strong></p><h4 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS AbstractQueuedSynchronizer"></a><strong>AQS AbstractQueuedSynchronizer</strong></h4><p>  抽象的队列同步器，定义了一套多线程访问共享资源的同步器框架，AQS提供了Node和ConditionObject，以及一系列基于unsafe底层的方法<br>  AQS通过控制state状态来判断锁的状态，对于可重入锁，如果state=0，则直接state=1，当前线程获取锁，如果state!=0，则判断当前线程是否已经获取锁，如果是，则state+1，不是则阻塞，代码执行完，相应的state-1，直到最后state-1=0，即释放锁<br>  非可重入锁发现state=1阻塞，反之设置state=1，用完释放直接state=0<br><font color=red><strong>AQS通过state的CAS来保存状态同步，state可以用来实现锁，信号量等，通过等待队列来存储等待锁的线程，通过类似CLH队列来实现前置节点状态改变触发唤醒后继节点的同步队列，通过ContinObject实现的条件队列，通过LockSupport/unsafe的park和unpark来实现线程阻塞和解除阻塞</strong></font></p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a><strong>可重入锁</strong></h4><p>又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是锁的同一个对象），不会因为之前已经获取锁还没释放而阻塞，可一定程度避免死锁</p><h4 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a><strong>CLH队列锁</strong></h4><p>CLH锁即Craig, Landin, and Hagersten (CLH) locks。CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。<br>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量ThreadLocal上进行<br><strong>实现原理</strong></p><ul><li>获取锁时，新建一个Node，将node中locked设置为true，表示需要锁，然后通过AtomicReferenceFieldUpdater原子更新器，将自己设置成尾节点，同时获取一个前驱节点的引用(通过ThreadLocal存储)，然后在此前驱节点的locked上自旋</li><li>释放锁时，如果当前节点不是tail节点，只需要设置locked=false，通知它的后继节点停止自旋，即后继节点的加锁成功，把自己设置成首节点</li></ul><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a><strong>非公平锁</strong></h4><ul><li>某个线程加锁时，会先尝试直接设置同步状态，成功就退出</li><li>第一步尝试失败后调用AbstractQueuedSynchronizer的acquire方法</li><li>AbstractQueuedSynchronizer的acquire方法中先调用子类tryAcquire方法，当等待队列为空或者队首节点持有线程就是当前线程则CAS设置同步状态</li><li>第三步也没加锁成功就加入CLH队列</li></ul><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h4><ul><li>直接调用AbstractQueuedSynchronizer的acquire方法</li><li>AbstractQueuedSynchronizer的acquire方法中先调用子类tryAcquire方法，发现锁没线程持有就直接尝试CAS设置同步状态，若是发现持有线程就是当前线程则将累计信号量</li><li>第二步没获取到锁就加入CLH队列</li></ul><p>参考：<br><a href="https://www.cnblogs.com/iou123lg/p/9464385.html" target="_blank" rel="noopener">AQS的前世今生</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="面向对象程序设计-OOP"><a href="#面向对象程序设计-OOP" class="headerlink" title="面向对象程序设计 OOP"></a><strong>面向对象程序设计 OOP</strong></h3><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li>封装 隐藏对象的属性和实现细节，仅提供公共的访问方式，将变化隔离，提高安全性</li><li>继承 提高代码复用性</li><li>多态 父类或接口定义的引用变量，可以指向子类或实现类的实例对象，提高程序拓展性</li></ul><h4 id="接口和继承的区别"><a href="#接口和继承的区别" class="headerlink" title="接口和继承的区别"></a><strong>接口和继承的区别</strong></h4><ul><li>继承：描述的是什么是一种什么，只能单继承,</li><li>接口：描述的是实现类具有哪些功能或行为，用来弥补单继承的缺陷</li></ul><h4 id="七种设计原则"><a href="#七种设计原则" class="headerlink" title="七种设计原则"></a>七种设计原则</h4><ul><li>单一职责原则SRP(Single Responsibility Principle) 类的功能要单一，不能包罗万象</li><li>开闭原则OCP(Open-Close Principle) 对拓展(增加功能)开放，对修改(修改原有功能)关闭</li><li>里氏替换原则LSP(the Liskov Substitution Principle) 子类可以替换父类，出现在父类能够出现的任何地方，比如你能帮你爸爸在奶奶家干活</li><li>依赖倒置原则DIP(the Dependency Inversion Principle) 高层次的模块不能依赖低层次的模块，它们都应该依赖于抽象，抽象不应该依赖于具体实现，具体实现应该依赖于抽象，比如：出国你要说你是中国人，而不是哪个村的人</li><li>接口分离原则ISP(the Interface Segregation Principle) 设计时采用多个与特定客户类有关的接口，比采用一个通用接口要好。接口糅合在一起维护时需要兼容</li><li>合成复用原则(Composite Reuse Principle, CRP) 尽量使用对象组合，而不是继承来达到复用的目的</li><li>迪米特法则Law of Demeter（最少知识原则 Least Knowledge Principle） 一个软件实体应当尽可能少的与其他实体发生相互作用</li></ul><h4 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a><strong>模式分类</strong></h4><ul><li>创建型5个：工厂方法、抽象工厂、单例、原型、建造者</li><li>结构型7个：桥接、享元、装饰、代理、外观、组合、适配器</li><li>行为型11个：职责链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h4><ul><li>普通工厂：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类</li><li>工厂方法类：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</li><li>抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类，实际是工厂的工厂</li></ul><h4 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 Singleton Pattern"></a><strong>单例模式 Singleton Pattern</strong></h4><ul><li>饿汉式：提前生成</li><li>懒汉式：用到的时候才生成</li><li>双检锁：dcl</li><li>枚举类：枚举类是安全线程</li><li>IoDH：内部静态类</li></ul><h4 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式 Builder Pattern"></a><strong>建造者模式 Builder Pattern</strong></h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式</p><h4 id="原型-Prototype-Pattern"><a href="#原型-Prototype-Pattern" class="headerlink" title="原型 Prototype Pattern"></a><strong>原型 Prototype Pattern</strong></h4><p>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式</p><h4 id="适配器模型-Adapter-Pattern"><a href="#适配器模型-Adapter-Pattern" class="headerlink" title="适配器模型 Adapter Pattern"></a><strong>适配器模型 Adapter Pattern</strong></h4><p>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)</p><h4 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式 Bridge Pattern"></a><strong>桥接模式 Bridge Pattern</strong></h4><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化，也叫接口模式</p><h4 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式 Composite Pattern"></a><strong>组合模式 Composite Pattern</strong></h4><p>组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式</p><h4 id="装饰模式-Decorator-Pattern"><a href="#装饰模式-Decorator-Pattern" class="headerlink" title="装饰模式 Decorator Pattern"></a><strong>装饰模式 Decorator Pattern</strong></h4><p>动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活</p><h4 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式 Facade Pattern"></a><strong>外观模式 Facade Pattern</strong></h4><p>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，实现高内聚低耦合</p><h4 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式 Flyweight Pattern"></a><strong>享元模式 Flyweight Pattern</strong></h4><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用</p><h4 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式 Proxy Pattern"></a><strong>代理模式 Proxy Pattern</strong></h4><p>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问</p><h4 id="职责链模式-Chain-of-Responsibility-Pattern"><a href="#职责链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="职责链模式 Chain of Responsibility Pattern"></a><strong>职责链模式 Chain of Responsibility Pattern</strong></h4><p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止</p><h4 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式 Command Pattern"></a><strong>命令模式 Command Pattern</strong></h4><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作，也叫动作模式；本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开</p><h4 id="解释器模式-Interpreter-Pattern"><a href="#解释器模式-Interpreter-Pattern" class="headerlink" title="解释器模式 Interpreter Pattern"></a><strong>解释器模式 Interpreter Pattern</strong></h4><p>定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码</p><h4 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式 Iterator Pattern"></a><strong>迭代器模式 Iterator Pattern</strong></h4><p>提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)</p><h4 id="中介者模式-Mediator-Pattern"><a href="#中介者模式-Mediator-Pattern" class="headerlink" title="中介者模式 Mediator Pattern"></a><strong>中介者模式 Mediator Pattern</strong></h4><p>用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互，迪米特法则典型</p><h4 id="备忘录模式-Memento-Pattern"><a href="#备忘录模式-Memento-Pattern" class="headerlink" title="备忘录模式 Memento Pattern"></a><strong>备忘录模式 Memento Pattern</strong></h4><p>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态，其别名为Token</p><h4 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式 Observer Pattern"></a><strong>观察者模式 Observer Pattern</strong></h4><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式</p><h4 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 State Pattern"></a><strong>状态模式 State Pattern</strong></h4><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)</p><h4 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 Strategy Pattern"></a><strong>策略模式 Strategy Pattern</strong></h4><p>定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</p><h4 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式 Template Method Pattern"></a><strong>模板方法模式 Template Method Pattern</strong></h4><p>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，是一种基于继承的代码复用技术</p><h4 id="访问者模式-Visitor-Pattern"><a href="#访问者模式-Visitor-Pattern" class="headerlink" title="访问者模式-Visitor Pattern"></a><strong>访问者模式-Visitor Pattern</strong></h4><p>提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p><p>参考：<a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">史上最全设计模式导学目录</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql分库分表</title>
      <link href="/2019/12/01/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2019/12/01/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h4><ul><li>读写分离：主从同步</li><li>垂直拆分：根据业务不同，进行分库</li><li>水平拆分：同一个库下，针对大表进行拆分</li><li>分库分表减轻了单表压力，提高了存储效率，但是带来了问题<ul><li>分布式唯一ID</li><li>分布式事务</li><li>跨库跨表分页，结果并集</li></ul></li></ul><h4 id="分库逻辑"><a href="#分库逻辑" class="headerlink" title="分库逻辑"></a><strong>分库逻辑</strong></h4><ul><li>以业务区分，如：用户库、订单库、商品库、交易库等</li><li>分库以后，对于某些跨库查询，只能是分开查，通过代码聚合，最好是在设计时，将部分信息缓存到库中，比如交易表里面有订单号</li></ul><h4 id="分表方式"><a href="#分表方式" class="headerlink" title="分表方式"></a><strong>分表方式</strong></h4><ul><li>以时间分：以日表、月表的形式<ul><li>优点：扩容简单，历史数据不用重新分布</li><li>缺点：单表可能会超大，存在数据热点，查一段时间的数据，需要拆分多表关联，表需要预先建好</li></ul></li><li>以自增主键分：主键取模，比如分成20张表，根据id/20取余数，而决定数据落哪张表<ul><li>优点：数据分布很均匀</li><li>缺点：扩容时，会导原有数据重新分布，同一个用户的多条数据，极大可能落到很多分表中，如果要查询一段时间多条数据，需要每个表都要去查</li></ul></li><li>以用户id分：通过用户id取模决定数据存储<ul><li>优点：同一个用户的相关数据，会落到同一张表</li><li>缺点：扩容时历史数据需要重新分布，存在数据热点，某些表会很大</li></ul></li><li>以范围切片：通过range，控制某一段的数据在指定表<ul><li>优点：扩容无需迁移数据</li><li>缺点：同一用户数据可能很分散，可能有热点，要所有分表查询，聚合难度大</li></ul></li><li>以一致性hash切片：通过hash环，虚拟节点，保证数据均匀分布<ul><li>优点：数据分布均匀，扩容只需一半数据迁移</li><li>缺点：历史数据分布很均匀，需要额外进行操作将数据取出</li></ul></li><li>自定义主键切片：通过Snowflake等生成唯一的分布式主键<ul><li>优点：无需迁移数据</li></ul></li></ul><h4 id="主从同步过程"><a href="#主从同步过程" class="headerlink" title="主从同步过程"></a><strong>主从同步过程</strong></h4><p>通过show slave status可以查看配置，当Slave_IO_Running和Slave_SQL_Running的状态都为Yes时，说明从库配置成功</p><ul><li>基于sql语句(statement-based replication, SBR 默认方式)：主库数据修改会记录到binarylog，从库通过IO线程将此binlog复制到自己的中继日志RelayLog中，从库通过sql线程读取binlog中的事件，将其重放到自己的数据上</li><li>基于行的复制(row-based replication, RBR)：按行进行复制</li><li>混合模式复制(mixed-based replication, MBR)：默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制</li></ul><h4 id="分库分表扩容和缩容"><a href="#分库分表扩容和缩容" class="headerlink" title="分库分表扩容和缩容"></a><strong>分库分表扩容和缩容</strong></h4><ul><li>停服迁移：需要提前发公告，迁移时间长，影响程序可用性，迁移失败要回滚，还得再挑时间，对开发压力大，容易出事故</li><li>升级从库：每台主库都会配一台从库，当要升级时，通过配置中心修改分库路由规则，同步配置从库升级为主库，解除主从关系，冗余数据清理，为新节点搭建新的从库 都是人工操作，时间长易出错</li><li>双写迁移：主要是针对数据迁移来说，将老数据迁移同步过去，要做好数据校验，并行一段时间再切断老库</li></ul><h4 id="分库分表如何才能无限扩容"><a href="#分库分表如何才能无限扩容" class="headerlink" title="分库分表如何才能无限扩容"></a><strong>分库分表如何才能无限扩容</strong></h4><p>分库分表多了，每个服务都需要创建一套连接池，维护应用要用到的数据库的连接，当服务在水平扩展时，这些数据库连接占用也会越来越多，导致数据库的连接数达到瓶颈，解决这个的思路就是“不要让应用连接所有数据库”</p><h4 id="如何避免热点问题"><a href="#如何避免热点问题" class="headerlink" title="如何避免热点问题"></a><strong>如何避免热点问题</strong></h4><ul><li><p>hash取模：没有热点，但是要数据迁移</p></li><li><p>range：不需要数据迁移，但是有热点问题<br>如何把两种结合？<br>设计一个分布式递增的id，引入group，group下面是db，db下面是table，首先根据id的range确定数据在哪个group，再根据hash取模确定数据在哪个db，再根据range确定数据在哪个table，这样维护好group的id范围、hash的取模范围、table的id范围，扩容时只需要新加一个group即可，上线时</p></li><li><p>升级从库：每台主库都会配一台从库，当要升级时，通过配置中心修改分库路由规则，同步配置从库升级为主库，解除主从关系，冗余数据清理，为新节点搭建新的从库 都是人工操作，时间长易出错</p></li></ul><p>参考：<a href="https://www.cnblogs.com/longfeiwang/p/10972494.html#_label4" target="_blank" rel="noopener">分库分表终极方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Http协议</title>
      <link href="/2019/11/27/Http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/11/27/Http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a><strong>Http1.0</strong></h4><ul><li>短暂连接，每次请求都要新开TCP连接</li><li>服务器不跟踪，也不记录过去的请求</li><li>不支持文件断点续传</li></ul><h4 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a><strong>Http1.1</strong></h4><ul><li>支持TCP长连接，流水线模式，在一次TCP连接上能发送多次请求和响应</li><li>支持文件断点续传</li><li>提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头</li><li>同一时间，针对同一域名下的请求，有一定数量限制</li></ul><h4 id="Http2-0"><a href="#Http2-0" class="headerlink" title="Http2.0"></a><strong>Http2.0</strong></h4><ul><li>支持多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务端推送</li></ul><h4 id="Https"><a href="#Https" class="headerlink" title="Https"></a><strong>Https</strong></h4><ul><li>TLS/SSL协议中使用了非对称加密，对称加密以及HASH算法</li><li>CA证书，数字证书，非对称加密，保存对方的公钥，私钥加密，公钥解密<ul><li>CA服务商的公钥已经提前植入到浏览器中</li><li>①服务端的公钥等信息发给CA，CA用自己的私钥给服务端公钥签名生成证书</li><li>②客户端请求服务端，拿到服务端证书后，通过CA公钥解密数字证书签名，验证服务器公钥是否合法</li><li>③客户端生成随机对称共享秘钥，通过服务端公钥加密，发送给服务端</li><li>④服务端通过私钥解密得到共享秘钥，之后双方以此共享秘钥做数据加解密</li></ul></li></ul><h4 id="为什么要用https"><a href="#为什么要用https" class="headerlink" title="为什么要用https"></a><strong>为什么要用https</strong></h4><ul><li>http易被拦截，https增加安全性</li><li>防止运营商拦截，http通信时，运营商会在里面插入各种广告</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA广播通信</title>
      <link href="/2019/11/27/JAVA%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/11/27/JAVA%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a><strong>通信方式</strong></h4><ul><li>单播：单台主机与单台主机通信</li><li>广播：单台主机与多台主机通信</li><li>组播：单台主机与选定的一组主机通信</li></ul><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a><strong>单播</strong></h4><ul><li>一对一通信，服务器及时响应客户端请求</li><li>服务端能针对每个客户端的每个请求发送不同的响应，容易个性化服务</li><li><strong>缺点：</strong>当客户机多、流量大是，服务器撑不住</li></ul><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a><strong>广播</strong></h4><ul><li>通信效率高，消息一下子就可以传递到某一网络内所有主机</li><li>服务端负载低，不用与每个客户端单独对话</li><li><strong>缺点：</strong>非常占用带宽，缺乏针对性，强制接收数据</li></ul><h4 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播/多播"></a><strong>组播/多播</strong></h4><ul><li>与广播相比，减少网络流量，部分定制化</li><li>与单播相比，提高发送报文效率</li><li><strong>缺点：</strong>没有纠错机制，丢包后难以补发</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis知识</title>
      <link href="/2019/11/27/MyBatis%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/27/MyBatis%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a><strong>运行原理</strong></h4><p><img src="/images/pasted-21.png" alt="运行原理"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合类知识</title>
      <link href="/2019/11/27/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/27/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h4><ul><li>就是一个数组 transient Object[] elements;当size&gt;0的时候，通过readObject()进行序列化输出</li><li>初始大小=10，扩容是按照1.5倍扩容，oldCapacity + (oldCapacity &gt;&gt; 1)</li><li>扩容时，是通过Arrays.copyOf -&gt; System.arraycopy(native) 来实现</li><li>适合随机读取，不适合插入删除，因为需要改变插入点或删除点之后的下标</li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h4><ul><li>双向链表实现，每一个节点，存储了上一个节点和下一个节点的指针，prev，next，item</li><li>没有初始化大小，也没有扩容机制</li><li>适合增加、删除等操作，删除时将删除的对象设置成null</li></ul><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a><strong>HashTable</strong></h4><ul><li>数据结构与hashmap是相同的，只是每个方法上都有synchronize关键字，来保证安全</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP知识</title>
      <link href="/2019/11/26/TCP%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/26/TCP%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>TCP协议全称是传输控制协议，就是要对数据的传输进行一定的控制，TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输<br>报文头<br><img src="/images/pasted-11.png" alt="TCP报文头部"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h4><p><img src="/images/pasted-13.png" alt="三次握手"><br><strong>为什么是三次握手，不是两次或四次</strong><br>答：如果是两次，服务端不知道客户端的情况，有可能客户端已经挂了，但是服务端还在分配资源，等待客户端传送数据，浪费服务端资源<br>如果是四次，因为三次已经足够，后面的四次，五次就显得浪费了</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h4><p><img src="/images/pasted-14.png" alt="四次挥手"><br><strong>为什么客户端最后还要等待2MSL</strong><br>答：①为了保证服务端能收到客户端的确认应答，如果客户端发完直接进入CLOSE状态，客户端给服务端的确认应答丢失，那服务端就无法正常关闭<br>②在2MSL内保证所有报文段都从网络中消失，不会再有失效的报文通过此连接传给服务端</p><p><strong>为什么是四次挥手</strong><br>答：服务端收到客户端的FIN请求时，仅仅表示客户端不再发数据给服务端了，但是服务端还是能再接收数据，并且服务端也未必全部信息都已经发送给客户端，所以服务端可以直接关闭，也可以发送一些数据后，再关闭，所以ACK和FIN是分开发送的，会多一次</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反射机制</title>
      <link href="/2019/11/26/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/11/26/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>java反射机制是指在运行状态中，对于任意一个类，都能过获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法，这种在运行时动态的获取信息以及动态调用对象的方法的功能成为java反射机制，其核心就是getMethod和invoke</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>通过对象  A a = new A(); a.getClass();</li><li>通过路径  Class.forName(“org.aaa.Student”);</li><li>通过类名  Class a = Student.class;</li><li>通过类加载器  ClassLoader classLoader = this.getClass().getClassLoader();<pre><code>Class clazz5 = classLoader.loadClass(className);</code></pre></li></ul><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><strong>代理模式</strong></h4><p>如果需要委托处理某一类业务，我们可以先在代理类中统一处理，然后再调用具体实现类</p><ul><li>静态代理：生成好的源代码，程序运行前.class文件已经存在了</li><li>动态代理：在程序运行时运用反射机制动态创建而成</li></ul><p>动态代理的两种实现方式</p><ul><li>jdk代理 基于接口的，通过反射实现</li><li>cglib代理，通过修改字节码，新增子类去集成原有类来实现</li></ul><h4 id="反射慢优化"><a href="#反射慢优化" class="headerlink" title="反射慢优化"></a><strong>反射慢优化</strong></h4><p>没有一个比直接调用更快了，使用反射主要用途就是开发各种通用框架，更灵活易扩展<br>原生反射(没有缓存Method) 大概比 直接调用 慢了 340倍<br>原生反射(缓存Method) 大概比 直接调用 慢了 9倍<br>优化要分两个方面：</p><ul><li>getMethod，底层是native方法，只能缓存method解决</li><li>invoke，底层也是native方法，可以通过asm技术去优化，但是asm需要生成新的class文件，然后再加载到jvm中，大部分时间会消耗在getMethod上<br>所以 通过method缓存+asm，可以大致接近直接调用，损耗就主要在asm生成一次class文件上</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA事件机制</title>
      <link href="/2019/11/26/JAVA%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/11/26/JAVA%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h4><ul><li>事件 一般继承自java.util.EventObject类，封装了事件源对象及跟事件相关的信息</li><li>事件监听器 实现java.util.EventListener接口,注册在事件源上,当事件源的属性或状态改变时,取得相应的监听器调用其内部的回调方法。</li><li>事件源 事件发生地地方，生成相应的事件对象，事件监听器注册在事件源上，事件源有个容器去持有这些监听器(list,set等)</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载Classloader</title>
      <link href="/2019/11/25/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/11/25/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="class-forName和classloader区别"><a href="#class-forName和classloader区别" class="headerlink" title="class.forName和classloader区别"></a><strong>class.forName和classloader区别</strong></h4><ul><li>class.forName除了将类加载进JVM，还会对类进行解释，执行类中的static块，当然还可以指定是否执行static块</li><li>classloader只将类加载进JVM，只有newInstance时才会执行static块</li></ul><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a><strong>加载阶段</strong></h4><ul><li>加载，将类的class文件加载到内存中，并创建一个Class对象</li><li>连接，负责把类的二进制文件合并到JRE中<ul><li>验证 验证类结构，是否与其他类协调一致</li><li>准备 为类的变量分配内存，设置默认值</li><li>解析 将类的二进制文件中符号引用替换为直接引用</li></ul></li><li>初始化，主要是对类变量初始化<ul><li>创建类的实例（new 、反射、反序列化）</li><li>调用某个类静态方法</li><li>访问某个类或者接口的类变量，或者为该变量赋值</li><li>初始化某个类的子类<img src=/images/pasted-63.png style="border:1px solid orange"/></li></ul></li></ul><p><strong>sun.misc.Launcher 是jvm的入口应用</strong></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h4><ul><li>bootstrapeClassloader 根类加载器，主要是加载核心类，如rt.jar，有jvm自身实现，不是Classloader的子类</li><li>extClassloader 扩展类加载器，负责加载jre的扩展目录，lib\ext</li><li>applicationClassloader 应用类加载器，负责加载有Classpath指定的jar包和路径</li></ul><h4 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a><strong>加载机制</strong></h4><ul><li>全盘负责：当一个类加载器负责一个类的加载时，该类所依赖的和引用的其他类也将由这个类加载器加载，除非显示声明</li><li>双亲委派：尝试让父类加载器，如果父类加载器无法加载时，才让从自己类路径加载，保证JDK核心类的优先加载，同时安全防护，防止核心类被覆盖</li><li>缓存机制：所有加载过的类都会被缓存</li></ul><h4 id="如何破坏双亲委派机制"><a href="#如何破坏双亲委派机制" class="headerlink" title="如何破坏双亲委派机制"></a><strong>如何破坏双亲委派机制</strong></h4><ul><li>双亲委派模式是jdk1.2才引入，对于以前已经存在的用户自定义类加载器加载，自然是只能妥协</li><li>理想状态下，每个类都是有基础类去加载，但是存在基础类去调用户类的场景，如jndi，jdbc，spi等，JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码，于是引入了 线程上下文类加载器(Thread Context ClassLoader)，通过设置线程的类加载器，在加载时，由父类加载器去调用子类加载器去加载类</li><li>动态模块化（OSGI）为了热发布，热部署而出现的，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库结构</title>
      <link href="/2019/11/22/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/"/>
      <url>/2019/11/22/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h4 id="页的引入"><a href="#页的引入" class="headerlink" title="页的引入"></a><strong>页的引入</strong></h4><p>数据库的数据是存储在磁盘中的，假设有5条记录，id=1到5，如果要查询id=5，就需要去遍历这5条数据，每次取出一条比较，一共要进行5次IO操作，但是引入页的概念后，mysql将多条数据存储在页中，每次读取数据，会将整页读取到内存中，在内存中进行比较，相比读取io这时间可忽略不计，加入id1~4存储在页1，id=5存储在页2，那只需要进行两次io操作，就能找到id=5<br><img src="/images/pasted-23.png" style="width:30%"></p><h4 id="页结构的弊端"><a href="#页结构的弊端" class="headerlink" title="页结构的弊端"></a><strong>页结构的弊端</strong></h4><p>如图中的页结构中数据，是链表的结构，这种结构的弊端就是增删容易，但是查询慢，需要遍历所有页，比如数据量100w，则需要从1开始遍历比较</p><h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a><strong>页目录</strong></h4><p>就是在页中存储着页目录，有此页目录，就能快速定位相应的数据<br><img src="/images/pasted-24.png" style="width:40%"></p><h4 id="多页结构"><a href="#多页结构" class="headerlink" title="多页结构"></a><strong>多页结构</strong></h4><p>mysql单页的大小是16kb，要存储更多的数据，就必须多页存储，多页也是采用链表的形式，于是跟页结构一样，多页模式也引入了目录，这中目录是针对<strong>页</strong>进行定位，而页里面的目录是针对<strong>行</strong>进行定位</p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><strong>存储引擎</strong></h4><ul><li>MyIsam，无事务，主要用于做从库查询，非聚簇索引，表结构(.frm)、表数据(.myd)、表索引(.myi) 三个文件存储，支持全文索引，字符串索引时用增量保存的方式，如第一个索引是‘preform’，第二个是‘preformence’，则第二个保存是‘7，ance’，这个明显的好处是缩短索引，但是不支持倒序提取索引，必须顺序遍历</li><li>InNodb，有事务，主要用于主库操作，聚簇索引，表结构(.frm)、表数据+表索引(.ibd) 两个文件存储，不支持全文索引</li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h4><p><strong>主键索引(Primary key)、唯一索引(unique index)、普通索引(index)和全文索引(fulltext)</strong><br>“聚簇”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储</p><ul><li>聚簇索引，索引和数据存放在一起，查到索引就查到了数据</li><li>非聚簇索引，将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因<br><img src="/images/pasted-8.png" alt="聚簇索引和非聚簇索引"></li></ul><p><strong>主键索引上没区别，主要是辅助键索引，聚簇索引只存储id</strong><br><strong>优势</strong></p><ul><li>索引和数据在一个文件，加载到内存，不必再去访问磁盘</li><li>辅助索引(二级索引)使用指针，而不是地址值，因为数据库的修改会改变原有地址值，用主键免去更新辅助索引</li></ul><p><strong>劣势</strong></p><ul><li>维护索引昂贵，插入新数据可能会导致分页</li><li>使用随机id(uuid)做主键，数据稀疏，可能比全表扫描慢<br><img src="/images/pasted-9.png" alt="使用场景"></li></ul><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a><strong>最左前缀匹配原则</strong></h4><ul><li>mysql从where后会一直从左往右一直匹配，直到遇到(&gt;、&lt;、between、like)停止，比如where a=1 and b=2 and c&gt;3 and d=4，如果是(a,b,c,d)顺序索引则d是无法使用索引的，如果是(a,b,d,c)的索引则a、b、d都能使用索引</li><li>=和in可以乱序，mysql查询优化器会帮你优化成可以识别的形式</li></ul><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a><strong>索引失效</strong></h4><ul><li>隐式转换，如varchar型的，条件用数字，where a=1</li><li>不符合最左前缀原则，符合索引未用到最左字段</li><li>like以%开头</li><li>索引列计算或者使用函数</li><li>用到or的，如果or里面的字段全有索引，还是会走索引的，推荐用union替换</li><li>扫描全表比用索引快的</li></ul><h4 id="不适合做索引的情况"><a href="#不适合做索引的情况" class="headerlink" title="不适合做索引的情况"></a><strong>不适合做索引的情况</strong></h4><ul><li>表数据更新频繁，大量的更新会频繁导致索引重建</li><li>唯一性差的字段，如性别、年龄等区别不大</li><li>不需要被查询用到的字段</li></ul><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a><strong>B-tree</strong></h4><p>平衡多路查找树，如果每个节点，最多有n个孩子，那么这样的树就叫做n阶B-tree，其数据结构特性：</p><ul><li>根节点至少有两个子节点</li><li>树中每个节点至多包含n(n&gt;2)个孩子</li><li>除根节点和叶子节点外，每个节点至少有ceil(n/2)向上取整个子节点</li><li>叶子节点都在同一层，即叶子节点深度一样</li><li>任意两个节点的子树高度差&lt;=1</li><li>假设每个节点包含m个关键字信息<ul><li>关键字按顺序升序排序k(i-1)&lt;k(i)</li><li>关键字的个数满足ceil(n/2)-1&lt;=m&lt;=n-1</li><li>指针pi指向k[i-1],k[i]的子树</li></ul></li></ul><h4 id="为什么主键通常是自增id"><a href="#为什么主键通常是自增id" class="headerlink" title="为什么主键通常是自增id"></a><strong>为什么主键通常是自增id</strong></h4><p>新增数据是顺序存储的，聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何设计秒杀系统</title>
      <link href="/2019/11/22/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/11/22/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a><strong>秒杀</strong></h4><p>简述：秒杀就两个核心问题，一个是高并发读，一个是高并发写，对应到架构核心点就是 </p><ul><li>高性能：秒杀涉及的就是高读和高写，高读尽量”少读”和”读少”，高写就做数据拆分</li><li>高可用：就是要提高系统的稳定性，注意服务不稳定、物理资源损坏、自身服务瓶颈、依赖服务不稳定，预防和解决突发问题，双机热备，异地多活等</li><li>一致性：秒杀的核心关注就是商品库存，不能出现超卖的情况</li></ul><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a><strong>高性能</strong></h4><p>一、动静分离：数据尽量少+路径尽量短</p><ul><li>数据拆分：目的是将动态页面改造成适合缓存的静态页面，比如用户信息，商品信息做静态数据，库存、倒计时时间等从后端获取</li><li>静态缓存：缓存整个http页面而不是仅仅缓存静态数据，如缓存到cdn</li><li>数据整合：一种是查询动态数据，将动态数据插入静态页面中，返回给用户的是完整的页面，对用户体验好；一种是直接展示静态页面，数据异步请求获取，对服务端性能友好，用户体验稍差</li></ul><p>二、热点数据</p><ul><li>热点识别<ul><li>静态热点：能够提前预测的热点。可根据当前大促的特点，如母婴专场，电子产品等，可通过预售报名、每日访问量大数据分析</li><li>动态热点：无法预测的热点。比如直播卖货、口罩等，突然就高了</li><li>因此需要实现动态发现热点能力<ul><li>通过nginx、agent等采集热点url，热点日志，最好异步方式，最好做到秒级实时</li><li>聚合分析热点数据，达到一定规则的热点数据，通过订阅推送到各链路系统，各系统根据自身情况处理热点，或限流或缓存，从而实现热点保护</li></ul></li></ul></li><li>热点隔离 将热点请求与普通请求区别开<ul><li>业务隔离：对于已知会产生热点的业务，进行缓存预热</li><li>系统隔离：通过分组或者单独域名，与原有系统分离开</li><li>数据隔离：可以启用单独的缓存集群或db</li></ul></li><li>热点优化<ul><li>缓存：</li><li>限流：</li></ul></li></ul><p>三、系统优化</p><ul><li>减少序列化：序列化大部分发生在rpc阶段，适当的将多个应用进行合并部署，从而减少不同应用之间rpc调用</li><li>直接输出流数据：只要涉及IO操作，都很费cpu，因为字符需要转换成字节，而这个转换又必须查表编码，对于静态字符串，直接缓存为字节流，减少编码转换</li><li>裁剪异常日志堆栈：超大流量下，频繁输出日志堆栈，会拖垮系统，可适当裁剪，可通过日志控制堆栈深度</li><li>去组件框架：对于极致要求下，合理减少框架依赖，但要注意安全问题</li></ul><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><strong>一致性</strong></h4><p>秒杀系统中，库存是个关键数据，卖不出去是个问题，超卖更是个问题，扣库存要准确，还要防止恶意刷单<br>一、扣库存方式</p><ul><li>下单扣库存：下单即扣减商品库存，利用事务控制很精确，但是会出现下了单大量不支付，但又占了位，比如遭竞争对手刷单</li><li>付款扣库存：付款才扣，则避免刷单，但是会导致部分用户下了单，却付不了款，用户体验差</li><li>预扣库存：下单预扣库存，如果超时未付款，则释放商品，虽不能完美解决恶意下单行为，能适当提高恶意行为成本</li></ul><p>二、实际如何扣库存<br>现在大都是采用预扣库存的方式，下单多久未付款就自动取消订单</p><ul><li>卖的出去：要防止恶意刷单，通过单人只能购买n件，识别频繁不付款的用户进行打标，进行次数阻断</li><li>避免超卖：库存超卖实际情况分两种，一种是大促手段，即使超卖，商户也可以通过补货来解决；二是营销手段，完全不允许库存为负，可通过事务，乐观锁，数据库字段设置成无符号整数等</li></ul><p>三、一致性的优化</p><ul><li>解决高并发读的问题，关键词是“分层校验”，只做不影响新能的检查工作，如用户是否有秒杀资格，商品状态是否正常，活动是否已结束，而不做一致性的校验，采用多层缓存方式，允许读取的是脏数据，只有等到真正写的时候，再保证最终一致性，做到高可用和一致性之间的平衡</li><li>解决高并发写的问题，要么优化现有db，要么换db选型<ul><li>秒杀的库存可以存在可持久化缓存中进行操作，如redis</li><li>高并发写的情况，主要是竞争数据库行锁，可通过应用层排队、数据层排队(如阿里开发的数据库基于DB层对单行记录做并发排队)，将库存分散成多条数据，只是查询的时候需要汇总</li></ul></li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h4><p>秒杀系统的流量监控，不是蜿蜒的，而是瞬间直接上升，对资源的消耗几乎是瞬间的</p><ul><li>流量削峰：秒杀最终能抢到的人是有限的，即大部分都是无效的请求，则需要延缓请求，甚至过滤掉无效请求<ul><li>入口层的答题：防止作弊，过滤机器人和脚本刷单；延缓请求，将峰值的时间跨度拉长，大大减缓数据库压力</li><li>业务层的排队：如消息队列，线程池加锁等待，本地顺序写文件在顺序读等，其本质是将一步操作变成两步，这样有弊端：1是请求积压，流量如果长时间持续，达到队列水位上限，同样会压垮队列，和直接丢弃没区别；2是用户体验，异步推送就有可能先发后至，影响部分敏感用户体验；</li><li>数据层的过滤：数据层的读写限流(超过阈值直接丢弃)、读缓存(缓存读请求，重复读直接过滤)、写校验(一致性校验，只保留有效的)。过滤的核心目的是通过减少无效请求的数据IO保障有效请求的IO性能</li></ul></li></ul><p>当一个系统面临高流量时，往往很难进行自我修复，系统设计也不是绝对完美，则在项目的整个生命周期中，要采用适当的手段去检验，去探测错误，同时还要有降级兜底方案</p><img src="/images/pasted-57.png" style="border:1px solid green" alt="高可用系统建设生命周期"    ><h4 id="流控"><a href="#流控" class="headerlink" title="流控"></a><strong>流控</strong></h4><ul><li>请求流控    尽可能将请求拦截在上游，因为实际能成交是有限的</li><li>客户端流控    设置页面访问限制，重复刷新限制，提交操作限制</li><li>后端系统流控 可以异步处理、消息队列、并发限制，达到系统流量限制的直接拒绝</li><li>数据库 库存扣减，乐观锁等</li></ul><h4 id="系统架构优化"><a href="#系统架构优化" class="headerlink" title="系统架构优化"></a><strong>系统架构优化</strong></h4><ul><li>读取加速：秒杀都是读多写少，可以静态文件分离、运用cdn、缓存等分摊压力</li><li>异步处理和排队：实现接口异步处理，快速响应，采用消息队列进行请求排队</li><li>无状态服务设计：相较于有状态服务，无状态服务更易扩展</li></ul><h4 id="系统扩容"><a href="#系统扩容" class="headerlink" title="系统扩容"></a><strong>系统扩容</strong></h4><ul><li>增加系统规格，增加机器配置，内存、带宽</li><li>水平扩展，无状态服务+负载均衡可以直接水平扩展，有状态服务则需要进行较为复杂的垂直扩展</li><li>后端系统扩展，缓存服务和数据库服务，都可以进行容量扩展</li></ul><h4 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a><strong>实时监控</strong></h4><ul><li>流量监控，服务器负载监控，jvm监控 pinpoint、grafana、skyworking</li><li>日志系统 ELK（Elasticsearch、Logstash、Kibana）</li><li>异常告警 邮件、短信、钉钉等</li><li>热点数据发现 </li></ul><h4 id="常见招式"><a href="#常见招式" class="headerlink" title="常见招式"></a><strong>常见招式</strong></h4><p>动静分离术、隔离术、限流术(队列+锁)、多级缓存术、热点发现术</p><p><img src="/images/pasted-54.png" alt="秒杀系统"></p><p>参考：<a href="https://segmentfault.com/a/1190000020970562" target="_blank" rel="noopener">一个秒杀系统的设计思考</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka专题</title>
      <link href="/2019/11/22/kafka%E4%B8%93%E9%A2%98/"/>
      <url>/2019/11/22/kafka%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="消息中间件比较"><a href="#消息中间件比较" class="headerlink" title="消息中间件比较"></a><strong>消息中间件比较</strong></h4><p><img src="/images/pasted-7.png" alt="消息中间件比较"></p><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a><strong>相关名词</strong></h4><p><img src="/images/pasted-15.png" alt="名词解释"></p><h4 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a><strong>主要概念</strong></h4><ul><li>一条消息，能够发给多个ConsumerGroup，只能被ConsumerGroup一个consumer消费</li><li>一个topic可能有多个partition，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力，在同一个topic内，它只保证在一个分区内消息是有序的，每个分区中数据也不一样<br><img src="/images/pasted-19.png" alt="topic分区"></li><li>为了保证数据的可靠性，Kafka会给每个分区找一个节点当带头大哥（Leader），以及若干个节点当随从（Follower）。消息写入分区时，带头大哥除了自己复制一份外还会复制到多个随从。如果随从挂了，Kafka会再找一个随从从带头大哥那里同步历史消息；如果带头大哥挂了，随从中会选举出新一任的带头大哥，继续笑傲江湖<br><img src="/images/pasted-20.png" alt="副本机制"></li><li>partition的出现是为了实现水平扩展，单个broker会成为性能瓶颈</li><li>partition对应一个文件夹，segment对应一对文件(.index和.log)，如果所有都存储在同一套文件中，需要把文件前面的部分删除，显然很难操作，但是用segment则很容易，且不影响当前的操作</li><li>新版offsert保存到了一个<strong>consumer_offsert的topic下，这个</strong>consumer_offsert 有50个分区，通过将group的id哈希值%50的值来确定要保存到哪一个分区，这样也是为了考虑到zookeeper不擅长大量读写的原因</li></ul><h4 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a><strong>消费模型</strong></h4><ul><li>push(推送模式) 消息由消息代理推送给消费者，并标记这条消息已经被消费，但是如果由于网络原因，消费者没有收到，可能造成消息丢失，消费者还可能消费不过来，造成阻塞</li><li>pull(拉取模式) kafka采用pull形式，由自己控制消费速率，以及消费进度，消费者可以按照任意的偏移量进行消费，比如重新消费，从最开始进行消费等</li></ul><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a><strong>网络模型</strong></h4><ul><li><p>Kafka Client：单线程Selector，适用于并发量链接数小的，逻辑简单，数据量小的，Consumer 和 Producer 都是使用的上面的单线程模式，这种对于数据量大的不合适，会造成阻塞<br><img src="/images/pasted-16.png" alt="单线程"></p></li><li><p>Kafka Server：多线程Selector，Acceptor 运行在一个单独的线程中，对于读取操作的线程池中的线程都会在 Selector 注册 Read 事件，负责服务端读取请求的逻辑<br><img src="/images/pasted-17.png" alt="upload successful"></p></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h4><ul><li>高可靠分布式存储模型，副本机制</li><li>高性能的日志存储，一个 Topic 下面的所有消息都是以 Partition 的方式分布式的存储在多个节点上的，同时LogSegment由两部分组成，.index和.log文件，index存储索引，log存储数据文件，从图上可以看出，1至1235在一个连续段中，采用<strong>稀疏索引</strong>，如要读取第911条数据，找到900的文件，911-900=11，找小于11最接近的是 [10,1367]，然后地址1367开始找第11条数据，这就是offset的过程<br><img src="/images/pasted-18.png" alt="kafka文件组成"><br>但是kafka不能有太多的partition文件，分区太多会导致随机IO，针对这一点，RocketMQ 把所有的日志都写在一个文件里面，就能变成顺序写，通过一定优化，读也能接近于顺序读</li><li>旧消息删除：kafka不管消息有没有消费，都会保存，针对历史消息删除，一种是基于时间，一种是基于partition文件大小，进行设置</li></ul><h4 id="如何实现exactly-once"><a href="#如何实现exactly-once" class="headerlink" title="如何实现exactly-once"></a><strong>如何实现exactly-once</strong></h4><p>如果消息传递不重试，就会丢失，如果重试，可能会重复发送，at-most-once，0.11.0以后kafka采用事务保证精确一次送达，两个策略：</p><ul><li>单producer 单topic 每个producer在初始化的时候分配一个pid，producer向指定的partition发送的消息中，都会携带一个从0单调递增的sequence，每次提交消息，broker会保存这个seq，收到新消息都会校验这个seq<ul><li>如果seq-curseq&gt;1表明中间还有消息没收到，Broker 拒绝该消息，Producer 抛出 InvalidSequenceNumber</li><li>如果seq-curseq&lt;1表明消息已经保存，为重复消息，Broker 直接丢弃该消息，Producer 抛出 DuplicateSequenceNumber</li><li>只有seq-curseq=1才是合法消息   </li></ul></li></ul><p>参考: <a href="https://www.jianshu.com/p/4bf007885116" target="_blank" rel="noopener">https://www.jianshu.com/p/4bf007885116</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-Spring</title>
      <link href="/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/"/>
      <url>/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/</url>
      
        <content type="html"><![CDATA[<h4 id="SpringMVC的加载流程"><a href="#SpringMVC的加载流程" class="headerlink" title="SpringMVC的加载流程"></a><strong>SpringMVC的加载流程</strong></h4><ul><li>用户访问前端控制器DispatchServlet</li><li>DispatchServlet请求处理映射器HandlerMapping去查询处理器Handler</li><li>DispatchServlet调用处理器Handler，返回视图ModelAndView</li><li>DispatchServlet请求视图解析器ViewResolver进行视图解析，返回View</li><li>DispatchServlet将View进行渲染，返回用户</li></ul><h4 id="AOP的实现原理"><a href="#AOP的实现原理" class="headerlink" title="AOP的实现原理"></a><strong>AOP的实现原理</strong></h4><p>答：AOP目的是为了让调用者和实现者解耦，实现方式</p><ul><li>jdk代理 基于接口的，通过反射实现织入</li><li>cglib代理 基于类的，通过动态生成被代理类的子类来增强，如果父类是final，是不能被代理的</li></ul><h4 id="注解底层是怎么实现的"><a href="#注解底层是怎么实现的" class="headerlink" title="注解底层是怎么实现的"></a><strong>注解底层是怎么实现的</strong></h4><p>答：注解是继承Annotation的特殊接口，在java运行时会通过动态代理生成相应的代理类Proxy1，通过代理类来设置相应的属性，我们使用反射实际获取的是这个代理类</p><h4 id="Spring中bean生命周期"><a href="#Spring中bean生命周期" class="headerlink" title="Spring中bean生命周期"></a><strong>Spring中bean生命周期</strong></h4><p><strong>四个阶段</strong></p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction<img src=/images/pasted-64.png alt="bean生命周期" style="border:1px orange solid" width=70% /></li></ul><p><strong>多个扩展点</strong><br>影响多个Bean</p><ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul><p>影响单个Bean<br>Aware Group1</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul><p>Aware Group2</p><ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</li></ul><p>生命周期</p><ul><li>InitializingBean</li><li>DisposableBean</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2019/11/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/11/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h4 id="java数据类型"><a href="#java数据类型" class="headerlink" title="java数据类型"></a><strong>java数据类型</strong></h4><ul><li>基本数据类型 int，long等 值传递</li><li>引用数据类型 对象 引用(地址)传递</li></ul><h4 id="浅拷贝特点"><a href="#浅拷贝特点" class="headerlink" title="浅拷贝特点"></a><strong>浅拷贝特点</strong></h4><ul><li>对于基础类型成员变量，是直接将值直接赋值给新对象的成员变量，老的对象成员变量修改，不影响新的</li><li>对于引用类型的成员变量，比如数组或者类对象，所以只是把原来的内存地址赋值给了成员变量，还是跟老对象的成员变量，指向同一份内存地址，当老对象改变时，会对新的有影响</li></ul><h4 id="深拷贝特点"><a href="#深拷贝特点" class="headerlink" title="深拷贝特点"></a><strong>深拷贝特点</strong></h4><ul><li>对于基础类型成员变量，跟浅拷贝一样</li><li>对于引用类型，会重新开辟一块区间，存储拷贝的内容，所以新对象的成员变量指向的地址是新的，跟老的不一样</li><li>对于多层对象的，每个对象都是先Clonable并且重写clone()方法，实现对象的串行层层拷贝</li><li>深拷贝比浅拷贝，更耗资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2019/11/21/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/11/21/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉查找树特点"><a href="#二叉查找树特点" class="headerlink" title="二叉查找树特点"></a><strong>二叉查找树特点</strong></h4><ul><li>所有的父节点最多只能有两个子节点</li><li>左子树上所有节点的值，小于或等于根节点的值</li><li>右子树上所有节点的值，大于或等于根节点的值</li><li>左右子树也一定分别为二叉树，即每一个子树都符合前面三条规则<br>这种树查找很方便，但是插入时，如果根节点足够大，就会导致大部分数据落在根节点的左边，变成一条线，这样几乎是线性查找，为了解决这个问题，就引入了平衡二叉树，也就是红黑树</li></ul><h4 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a><strong>红黑树特点</strong></h4><ul><li>节点是红色或者黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点</li><li>每个红色节点的子节点都是黑色</li><li>从任意节点到其叶子节点的所有路径，都包含相同的黑色节点<br>当插入数据时，红黑树的平衡会被打破，需要重新调整</li></ul><h4 id="如何保持平衡"><a href="#如何保持平衡" class="headerlink" title="如何保持平衡"></a><strong>如何保持平衡</strong></h4><ul><li>变色：节点由红变黑，或者由黑变红</li><li>左旋转：逆时针旋转，使父节点被右侧孩子节点取代，自己成为左孩子</li><li>右旋转：顺时针旋转，使父节点被左侧孩子节点取代，自己成为右孩子</li></ul><h4 id="红黑树定理论"><a href="#红黑树定理论" class="headerlink" title="红黑树定理论"></a><strong>红黑树定理论</strong></h4><ul><li>从根到叶子节点的最长的可能路径，不多于最短的可能路径的两倍长</li><li>树高(h)不大于2倍红黑树的深度(bd)，即h&lt;2bd</li><li>一棵树拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</li></ul><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a><strong>二叉树遍历</strong></h4><img src="/images/pasted-55.png" width = "20%" height = "100%" div align=center alt="二叉树示意图" />- 先序遍历 <font color=red>V</font>LR- 中序遍历 L<font color=red>V</font>R- 后序遍历 LR<font color=red>V</font><p>区别主要是父节点的位置，遍历时，如果下一个节点有子节点，先到子节点遍历<br><img src="/images/pasted-48.png" alt="普通二叉树"></p><ul><li>先序：ABDEGHCF</li><li>中序：DBGHEACF</li><li>后序：DHGEBFCA</li></ul><p>参考 <a href="http://www.360doc.com/content/18/0904/19/25944647_783893127.shtml" target="_blank" rel="noopener">五分钟搞懂什么是红黑树</a><br><a href="https://www.cnblogs.com/gofighting/p/5437998.html" target="_blank" rel="noopener">红黑树为什么效率高</a><br><a href="https://www.jianshu.com/p/45d75aeb3b01" target="_blank" rel="noopener">gif二叉树遍历</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-基础知识</title>
      <link href="/2019/11/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h4><ul><li>进程是资源的最小单位，线程是程序执行的最小单位</li><li>进程有自己独立的地址空间</li></ul><h4 id="java参数传递"><a href="#java参数传递" class="headerlink" title="java参数传递"></a><strong>java参数传递</strong></h4><p>答：java方法的调用，都是值传递，比如swap(a,b),传进去a，b的值，都是不会改变的</p><h4 id="Object类有哪些方法"><a href="#Object类有哪些方法" class="headerlink" title="Object类有哪些方法"></a><strong>Object类有哪些方法</strong></h4><p>答：equals，hashCode，toString，clone，finalize，wait，notify，nitifyAll</p><h4 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a><strong>== 和 equals的区别</strong></h4><p>答：equals是对象的方法，对于非String对象而言，equals就是==，所以没区别，但是String重写了equals方法，所以String.equals比较的是内容是否相等，不是存储地址</p><h4 id="对象为什么重写equals-，必须重写hashCode"><a href="#对象为什么重写equals-，必须重写hashCode" class="headerlink" title="对象为什么重写equals()，必须重写hashCode()"></a><strong>对象为什么重写equals()，必须重写hashCode()</strong></h4><p>答：因为Object.hashCode()是底层native方法，返回的是对象的内存地址，如果equals()返回true，则hashcode一定相同，不重写hashcode就会出现两个对象相同，但是hashcode不同</p><h4 id="String，StringBuilder，StringBuffer区别"><a href="#String，StringBuilder，StringBuffer区别" class="headerlink" title="String，StringBuilder，StringBuffer区别"></a><strong>String，StringBuilder，StringBuffer区别</strong></h4><p>答：String是final class，不能被继承，被创建就不能更改<br>StringBuilder是不定长的，底层通过System.arrayCopyOf()实现字符拷贝<br>StringBuffer是线程安全的StringBuilder，就是多加了syncronize<br>不要用String+String，因为String的改变，是直接丢弃原有的字符串，重新在内存中申请地址，拼装好后返回新字符串，Stringbuilder实际改变的是同一个对象</p><h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final,finally,finalize区别"></a><strong>final,finally,finalize区别</strong></h4><ul><li>final是修饰符，修饰类时则该类不能被继承，修饰方法时则该方法不能被重写，修饰变量时则该变量不能被修改，只能在定义时初始化或者构造函数初始化</li><li>finally是异常处理的环节，用来执行try-catch后的操作，常用来关闭连接，关闭io流等</li><li>finalize是类似c++中的析构函数，用来在对象生命周期结束时，系统自动调用，因为内存中是存在着垃圾回收器不能处理的情况的，比如①native代码中调用C++的malloc()函数来分配内存，除非用free()才能释放，否则内存不能释放，可能造成内存泄露；②打开的文件资源，也不属于垃圾回收范围；一旦垃圾回收器准备好释放对象占用的空间，首先去会调用finalize()进行一些必要的清理工作，只有到下一次gc时，再判断对象是否可达，如果不可达才会真正执行回收动作，否则对象会“复活”，可见finalize加长了gc的流程，如果重写finalize方法抛出异常，可能gc一直进行不下去，最后导致OOM，一般不要写，像文件流，连接池这种，都是提供close方法，来进行显示回收，FileInputStream等中覆盖finalize仍是去执行close方法</li></ul><h4 id="serialVersionUID如果不定义会怎样"><a href="#serialVersionUID如果不定义会怎样" class="headerlink" title="serialVersionUID如果不定义会怎样"></a><strong>serialVersionUID如果不定义会怎样</strong></h4><p>答：SerialVerionUID 用于对象的版本控制，不指定的后果是,当你添加或修改类中的任何字段时, 则已序列化类将无法恢复, 因为为新类和旧序列化对象生成的serialVersionUID将有所不同，会导致类修改以后，历史的对象无法反序列化成当前类</p><h4 id="为什么wait，notify在Object，而不在Thread"><a href="#为什么wait，notify在Object，而不在Thread" class="headerlink" title="为什么wait，notify在Object，而不在Thread"></a><strong>为什么wait，notify在Object，而不在Thread</strong></h4><ul><li>wait和notify不仅仅是普通方法和同步工具，他们是两个线程之间的通信机制</li><li>每个对象都可上锁</li><li>为了进入代码的临界区，线程需要锁并等待锁，而不是需要去关心哪个线程在持有锁</li><li>监视器思想，所有对象都有个监视器，线程在监视器上等待</li></ul><h4 id="为什么java不支持多重继承"><a href="#为什么java不支持多重继承" class="headerlink" title="为什么java不支持多重继承"></a><strong>为什么java不支持多重继承</strong></h4><p>答：因为java是面向对象的语言，对象不存在即是这个又是那个的情况，比如，同时如果多继承，那么A继承B和C，当B和C里面有方法一样时，A到底重载的不知道是哪一个，同时还有可能导致菱形继承，需要更多的规则来实现，违背了java简单的本质</p><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><strong>wait和sleep的区别</strong></h4><ul><li>原理不同：sleep是线程的方法，它会使此线程暂停，而把执行机会交给其他线程；wait是Object的方法，用于线程间通信，会让持有该对象锁的线程等待，直到其他线程唤醒或者自己指定时间醒来</li><li>对锁的处理机制不同：sleep是让线程休息一会，不涉及线程间通信，不会释放锁；wait会释放锁，让其他线程能进入同步块</li><li>使用区域不同：wait必须要放在同步代码块中，sleep可以放在任何地方</li></ul><h4 id="wait为什么要放到同步代码中"><a href="#wait为什么要放到同步代码中" class="headerlink" title="wait为什么要放到同步代码中"></a><strong>wait为什么要放到同步代码中</strong></h4><p>答：这是java设计是为了避免出现lost wake up问题，意思就是不放在同步代码块，就可能出现先notify后wait的情况，导致最后出现线程一直wait下去</p>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注册中心</title>
      <link href="/2019/11/20/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2019/11/20/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h4 id="注册中心功能点"><a href="#注册中心功能点" class="headerlink" title="注册中心功能点"></a><strong>注册中心功能点</strong></h4><ul><li>服务发现</li><li>服务配置</li><li>健康监测<br>目前用的最多的注册中心有以下几种</li><li>zookeeper CP型 TCP长连接</li><li>eureka    AP型 心跳监控</li><li>nacos     AP型 心跳监控</li></ul><p><strong>为什么不用DNS做注册中心</strong></p><ul><li>dns只是ip级别的，无法处理端口等信息</li><li>携带的数据较少，无法传递参数，如节点权重、序列化方式</li><li>没有节点状态管理，如果是外部dns服务器，无法剔除坏死节点</li></ul><p><strong>如何保证注册中心的高可用？</strong></p><ul><li>任意节点的宕机，不会影响到集群的不可用，由其他节点分摊路由</li><li>尽量保持同一个</li><li>本地缓存成功同步的数据，如果注册中心全部挂掉，那服务之间的调用应该仍然可用<br><a href="https://www.jianshu.com/p/5014bb302c7d" target="_blank" rel="noopener"><strong>服务注册中心架构演进</strong></a></li></ul><h4 id="为什么注册中心要AP，而不能是CP？"><a href="#为什么注册中心要AP，而不能是CP？" class="headerlink" title="为什么注册中心要AP，而不能是CP？"></a>为什么注册中心要AP，而不能是CP？</h4><ul><li>因为CP系统，在发生脑裂的情况下，为了保证数据一致性，直接舍弃了可用性，比如：一个机房的A和B服务，本身网络可以连通，A与B可以直接本地访问，但是由于注册中心挂了，导致A无法访问到B</li><li>在大型分布式系统中，为了达到顺序一致性，需要向不同的机器不停的写数据，以保持数据都实时更新，维护一致性的成本比可用性代价更高</li></ul><p><strong>可以说在实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性，这是注册中心设计应该遵循的铁律！<a href="http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/" target="_blank" rel="noopener">阿里巴巴为什么不用 ZooKeeper 做服务发现</a></strong></p><p><strong>zk适合做粗粒度的分布式锁，分布式选主，主备高可用切换等不需要高TPS的场景，这些需求往往集中在大数据、离线任务等相关领域，因为大数据领域，讲究分割数据集，并且大部分时间分任务多进程/线程并行处理数据集，但是总在一些点上，需要将这些任务和进程统一协调，这时候zk发挥了巨大用武之地</strong></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAP理论</title>
      <link href="/2019/11/20/CAP%E7%90%86%E8%AE%BA/"/>
      <url>/2019/11/20/CAP%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C(Consistency)一致性"></a><strong>C(Consistency)一致性</strong></h4><p>分布式系统中，所有节点访问的都是同一份最新的数据副本</p><ul><li>强一致：任意时刻所有节点中数据是一样的，都是最新数据</li><li>弱一致：任意时刻多有节点中数据可能不一样</li><li>最终一致：弱一致性的特殊实现，如DNS有多级缓存，并不是修改了在全球节点立马生效</li></ul><h4 id="A-Availability-可用性"><a href="#A-Availability-可用性" class="headerlink" title="A(Availability)可用性"></a><strong>A(Availability)可用性</strong></h4><p>集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</p><h4 id="P-Partition-tolerance-分区容错性"><a href="#P-Partition-tolerance-分区容错性" class="headerlink" title="P(Partition tolerance)分区容错性"></a><strong>P(Partition tolerance)分区容错性</strong></h4><p>集群由于网络原因，被分割成了两部分，这两部分不能互相通信，系统能否继续正常工作</p><p>P是必备的，能选择的只有A、C，所以组合是CP或者AP<br>CP：系统保持强一致性，但是不一定高可用，如zookeeper在选举的时候，是不可用的<br>AP：系统保证高可用，但是读取的数据，可能会是过期数据，如eureka，nacos</p><p>放弃A就是ACID，放弃C就是BASE</p><h4 id="关系型数据库事务特性-ACID"><a href="#关系型数据库事务特性-ACID" class="headerlink" title="关系型数据库事务特性(ACID)"></a><strong>关系型数据库事务特性(ACID)</strong></h4><ul><li>Atomicity 原子性 是指事务是一个不可分割的工作单位，要么都发生，要么都不发生</li><li>Consistency 一致性 数据事务不能破坏关系数据的完整性和业务逻辑上的一致性</li><li>Isolation 隔离性 并发的事务之间是相互隔离的</li><li>Durability 持久性 该事务对数据库所做的更改，便持久的保存在数据库中，不会被回滚，即使出现任何宕机，也不影响以前的提交</li></ul><h4 id="分布式数据库事务特性-BASE"><a href="#分布式数据库事务特性-BASE" class="headerlink" title="分布式数据库事务特性(BASE)"></a><strong>分布式数据库事务特性(BASE)</strong></h4><ul><li>BA Basically Available 基本可用：系统能够基本运行，一直提供服务</li><li>Soft-satte 软状态：系统不要求保持强一致性</li><li>Eventually consistent 最终一致性：系统需要在某一时刻后达成一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper一致性原理</title>
      <link href="/2019/11/17/Zookeeper%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/17/Zookeeper%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="二阶段提交-2PC"><a href="#二阶段提交-2PC" class="headerlink" title="二阶段提交 2PC"></a><strong>二阶段提交 2PC</strong></h4><p>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><ul><li>一阶段是Prepare 准备阶段或投票阶段 数据准备 协调者向所有参与者节点发送准备消息</li><li>二阶段是Commit 提交阶段或执行阶段 根据所有参与者返回结果来确定如何操作<br>优点：原理简单，实现方便<br>缺点：</li><li>同步阻塞:所有参与者是同步事务阻塞</li><li>单点故障:协调者一旦下线，所有参与者的提交阻塞</li><li>数据不一致:在提交阶段，如果发生仿若故障，会导致部分提交不成功</li><li>容错机制不完善:当提交阶段协调者和参与者都down，即使有新的协调者，原来的处理情况也丢失了</li></ul><h4 id="三阶段提交-3PC"><a href="#三阶段提交-3PC" class="headerlink" title="三阶段提交 3PC"></a><strong>三阶段提交 3PC</strong></h4><ul><li>一阶段是CanCommit 协调者询问所有参与者能否提交</li><li>二阶段是PreCommit 协调者通知参与者准备</li><li>三阶段是DoCommit  通知所有参与者执行提交<br>相比2PC提升点：引入超时机制，改善同步阻塞和单点故障，但并不能避免，尤其是参与者在提交阶段收不到协调者消息，也会默认提交，此时其他参与者可能已经收到了abort消息，从而有可能导致数据不一致，这也是基于概率做的判断，</li></ul><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h4><p>此算法就是为了解决 一个分布式系统如何就某个值(决议)达成一致</p><ul><li>一阶段 读：提议者发起提案编号k，接收者收集提议，比较k值大小，并回复比对结果</li><li>二阶段 写：<ul><li>收到回复，超过半数，则服从多数，发起提交请求；未超过半数，则增大k值，重新进行一阶段</li><li>收到提交确认，如果超过一半，结束，将信息同步给learner；如果未超过一半，则增大k值，重新进行一阶段<br><img src="/images/pasted-5.png" alt="paxos算法"></li></ul></li></ul><h4 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a><strong>ZAB协议</strong></h4><p>是专门为zookpper实现分布式协调功能而设计的，ZAB协议的核心是 整个zk集群中只能有一个leader，能将客户端的写操作转化为事务(或提议proposal)，Leader在数据写完后，将向所有follower节点发送广播请求，并等待回复，只要超过半数的follower节点回复OK，则leader节点向所有follower发送commit消息，将leader上的数据同步到follower节点</p><ul><li>发现阶段：等同paxos的读阶段</li><li>同步阶段：确保过半的follower已经提交了前任leader期间的所有事务</li><li>广播阶段：等同paxos的写阶段</li></ul><h4 id="paxos和zab区别"><a href="#paxos和zab区别" class="headerlink" title="paxos和zab区别"></a><strong>paxos和zab区别</strong></h4><ul><li>目标不一样<ul><li>paxos用于构建分布式一致性状态机系统</li><li>zab用于构建分布式高可用主备系统</li></ul></li><li>zab比paxos多一个同步阶段，目的是为了确保前任周期内的事务都已提交</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA引用类型</title>
      <link href="/2019/11/17/java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/11/17/java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="强引用StrongReference"><a href="#强引用StrongReference" class="headerlink" title="强引用StrongReference"></a><strong>强引用StrongReference</strong></h3><p>最常见的引用，如：String s = new String(“aa”);就是强引用，当申明一个变量并指向一个实例时，就是创造了一个强引用，如果强引用一直存在，GC宁肯报OOM，也不会回收它，如果设置 s=null，就表是后面的String对象已经没有再引用了，GC就会回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">B b = new B(a);</span><br><span class="line">a = null;</span><br></pre></td></tr></table></figure><p>上面的代码，new的A对象不会被回收，因为它被B强引用了，这样很容易造成内存泄露</p><h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a><strong>软引用SoftReference</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p>如果内存足够，不会回收软引用对象，如果内存不够，则GC开始回收软引用占用的内存，可以用来实现内存敏感的高速缓存，如：网页的后退键，页面打开浏览，浏览完毕后设置成软引用，如果没被回收，继续使用；被回收了，重新构建页面对象</p><h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a><strong>弱引用WeakReference</strong></h3><p>弱引用对象具有更短的生命周期，如果GC扫描它锁管辖的内存区域，如果发现只具有弱引用的对象，不管内存空间，直接回收。<br>当你想引用一个对象，但又不想干预它的生命周期，这时就用弱引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class VeryBigWeakReference extends WeakReference&lt;VeryBig&gt;</span><br></pre></td></tr></table></figure><h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a><strong>虚引用PhantomReference</strong></h3><p>形同虚设，如果一个对象仅持有虚引用，那就和没有被引用一样，任何时候都有可能被GC，主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列 （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现还有虚引用，则会把这个虚引用加入到与之关联的队列中</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2019/11/17/Thread/"/>
      <url>/2019/11/17/Thread/</url>
      
        <content type="html"><![CDATA[<h4 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a><strong>五种状态</strong></h4><ul><li>创建状态 在生成线程对象，并没有调用该线程的start方法</li><li>就绪状态 调用start方法后，或被唤醒，都进入就绪状态，等待线程调度</li><li>运行 线程调度程序将处于就绪状态的线程，设置成当前线程，此时开始运行run函数中的代码</li><li>阻塞状态 线程正在运行时被暂停，通常是为了等待某个资源就绪之后再运行，sleep、suspend、wait都可以导致线程阻塞</li><li>死亡状态 run方法执行结束或调用stop方法后</li></ul><h4 id="start和run的区别"><a href="#start和run的区别" class="headerlink" title="start和run的区别"></a><strong>start和run的区别</strong></h4><p>run是普通的方法调用，与主线程同步，要run方法执行完成后，主线程才能继续执行<br>start是新起的子线程，与主线程异步，不影响主线程的继续执行，这是实现多线程的关键点</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a><strong>interrupt</strong></h4><p>中断并不能马上结束线程，而是向线程发送中断指令，同时系统抛出InterruptedException，所以要先捕捉InterruptedException，再跳出循环</p><h4 id="stop-已被废弃"><a href="#stop-已被废弃" class="headerlink" title="stop(已被废弃)"></a><strong>stop(已被废弃)</strong></h4><p>本质上是不安全的，停止线程会导致它解锁所有已锁定的监视器，如果监视器保护的对象任何一个处于不一致状态，别的线程再访问这些对象时，可能导致任意行为，完全不可控</p><h4 id="suspend和resume为什么弃用"><a href="#suspend和resume为什么弃用" class="headerlink" title="suspend和resume为什么弃用"></a><strong>suspend和resume为什么弃用</strong></h4><p>这两个是为了实现线程的挂起和恢复，但是挂起时并不释放对象锁，如果线程t1调用suspend阻塞一个持有一个锁的线程t2，那么，该锁在线程t2恢复之前是不可用的。如果t1试图获得同一个锁，那么t1也阻塞，程序死锁：被挂起的线程t2等着被恢复，而将其挂起的线程t1等待获得锁。应该用wait，notify来替代</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a><strong>join</strong></h4><p>线程A启动后，调用A.join()，这个时候，主线程会等待线程A执行完后，再继续执行</p><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><strong>wait和sleep的区别</strong></h4><ul><li>wait是Object的方法，wait会释放当前持有的运行锁，将cpu等资源释放，必须要调用notify()、notifyall()、超时后才被唤醒，需要写在同步代码块中，不会抛出异常</li><li>sleep是Thread的方法，不释放锁和资源，到时间点自动苏醒，不需要在同步代码中，会抛出异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2019/11/17/ThreadLocal/"/>
      <url>/2019/11/17/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h3 id="线程本地变量"><a href="#线程本地变量" class="headerlink" title="线程本地变量"></a><strong>线程本地变量</strong></h3><p>和Syncronize的区别，sync是为了变量线程间共享，而ThreadLocal是为了变量线程独享</p><ul><li><p>ThreadLocal类用于存储以线程为作用域的数据，线程之间数据隔离</p></li><li><p>ThreadLocalMap类是ThreadLocal的静态内部类，通过操作Entry来存储数据</p></li><li><p>Thread类内部维持一个ThreadLocalMap类实例(threadLocals)</p><p>  ThreadLocalMap中Entry继承WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，key是ThreadLocal本身，采用弱引用，当key被回收，entry对象也会被回收，但是当key为null的时候，value就不可访问了，导致内存泄露，所以ThreadLocalMap自己在get()/set()/remove()时，会去判断key是否为null，如果是，会把value置为null，这样下次gc就能回收了<br>  一个线程一个ThreadLocalMap可以存储多个ThreadLocal对象，entry数组存储<br><img src="/images/pasted-3.png" alt="ThreadLocal内存分布"></p></li></ul><h3 id="为什么不直接用成员变量"><a href="#为什么不直接用成员变量" class="headerlink" title="为什么不直接用成员变量"></a><strong>为什么不直接用成员变量</strong></h3><p>如果是类的成员变量，那多个线程在操作同一个对象时，变量值改变会互相影响，比如对象A的实例，传给不同的线程处理，就有可能产生不同的结果，因为引用指向的是同一个对象地址</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li>线程内数据传递，如：traceId，上下文信息等</li><li>管理request作用域的bean，如：gateway只能读取一遍request的请求内容，可以缓存到ThreadLocal，供后续的操作使用</li></ul><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a><strong>demo</strong></h3><p>ThreadLocal作为类的成员变量，当多线程操作同一个对象实例时，互不影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutiThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal tl = ThreadLocal.withInitial(MutiThreadLocal::init);</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal t2 = ThreadLocal.withInitial(MutiThreadLocal::init);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aaa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSth</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        tl.set(s);</span><br><span class="line">        t2.set(s+<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSth2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t2.get().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MutiThreadLocal mutiThreadLocal = <span class="keyword">new</span> MutiThreadLocal();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            mutiThreadLocal.setSth(<span class="string">"ss"</span>);</span><br><span class="line">            System.out.println(mutiThreadLocal.getSth1());</span><br><span class="line">            System.out.println(mutiThreadLocal.getSth2());</span><br><span class="line">        &#125;,<span class="string">"a"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            mutiThreadLocal.setSth(<span class="string">"dd"</span>);</span><br><span class="line">            System.out.println(mutiThreadLocal.getSth1());</span><br><span class="line">            System.out.println(mutiThreadLocal.getSth2());</span><br><span class="line">        &#125;,<span class="string">"b"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-4.png" alt="多个ThreadLocal"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA工具</title>
      <link href="/2019/11/16/IDEA%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/11/16/IDEA%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h4 id="1-2019-2版本激活"><a href="#1-2019-2版本激活" class="headerlink" title="1.2019.2版本激活"></a>1.2019.2版本激活</h4><ul><li>下载链接: <a href="https://pan.baidu.com/s/1QPV5jVxZaFD6w_NH8ZaOcw" target="_blank" rel="noopener">https://pan.baidu.com/s/1QPV5jVxZaFD6w_NH8ZaOcw</a> 提取码: fg64</li><li>将下载的 jetbrains-agent.jar 放到工作目录下</li><li>试用模式进入，点击Help&gt;Edit Custom VM Options</li><li>增加 -javaagent:$USER_HOME/IdeaProjects/jetbrains-agent.jar</li><li>关闭IDEA，重启，选择Help&gt;Register 选择Activation Code，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 命令大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API网关</title>
      <link href="/2019/11/15/API%E7%BD%91%E5%85%B3/"/>
      <url>/2019/11/15/API%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><strong>网关，作为进入系统唯一的入口</strong><br><strong>主要功能</strong></p><ul><li>统一接入：作为对面的门面，具备统一编码规则、公共参数、返回格式、错误申明和处理方式、加签加解密身份认证</li><li>安全防护：只有网关能外网访问，其他微服务都内网通讯，还能设置黑白名单</li><li>负载均衡：支持水平扩展，微服务心跳监控，实时上下线</li><li>协议适配：将内部微服务协议转换，对外暴露统一的协议，如内部rpc，http等，对外输出是http </li><li>流量控制：限流，降级，熔断</li><li>流量统计：统计接口调用频次，调用耗时，生成报表</li></ul><p><strong>网关分类</strong></p><ul><li>面向web网页</li><li>面向移动端</li><li>面向合作伙伴OpenApi</li><li>企业内部扩展 Api</li><li>面向IOT设备 物联网如工业传感器的数据过滤和协议转换</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap</title>
      <link href="/2019/11/14/hashmap/"/>
      <url>/2019/11/14/hashmap/</url>
      
        <content type="html"><![CDATA[<h4 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a><strong>演进过程</strong></h4><ul><li>线性检索：所有的数据遍历一遍，如数组，链表等线性结构，时间复杂度O(n)</li><li>二分查找：一般是取中间的数，进行比较，这样值用遍历一半的数，这个有个前提是必须是有序的，时间复杂度O(logn)</li><li>hash表：就是用一个数组，每个下标根据hash计算出来，整个数组中会有空值存在，很费空间，但是查找很快，时间复杂度O(1)</li><li>hash表改款：通过hashcode mod(数组长度)求出下标</li><li>hash冲突：存在mod以后，下标是同一个，所以hash冲突的地方，采用链表存储</li></ul><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a><strong>基本结构</strong></h4><p>由数组和链表构成，数组用来确定group，当hash碰撞时，存储Entry链<br>HashMap在底层是将key-value当成一个整体在处理，即Entry对象</p><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a><strong>操作步骤</strong></h4><ul><li>key的hashcode ==》 (h=key.hashCode())^(h&gt;&gt;&gt;16) &gt;&gt;&gt;右移补0</li><li>put时，根据key确定数组下标「(数组长度-1)&amp;key的hashcode」，遍历这个位置链表数据，如果遇到key相等，则更新，没有，则存入</li><li>当get时，先根据key确定数组下标，再取出key-value对链表，遍历比较key是否相等，相等取出，不相等返回空</li></ul><p><img src="/images/pasted-2.png" alt="存储结构"></p><table><thead><tr><th>JDK版本</th><th>节点数&gt;=8</th><th>节点数&lt;= 6</th><th>链表插入</th></tr></thead><tbody><tr><td>1.8以前</td><td>数组+单向链表</td><td>数组+单向链表</td><td>头插</td></tr><tr><td>1.8以后</td><td>数组+红黑树</td><td>数组+单向链表</td><td>尾插</td></tr></tbody></table><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a><strong>参数解析</strong></h4><ul><li>负载因子(loadFactor)，默认是0.75，可在创建时自定义</li><li>初始容量(initialCapacity)，默认是16，每次扩容以2的幂次方扩充，16和2<sup>n</sup>是为了在位运算(2<sup>n</sup>-1，转换成2进制全是1，跟传入的数据转2进制进行 与 操作，缺少的位补0，这就由低位的数字来决定最终的结果)的时候，使数据的分布跟输入保持一致，即只要hashcode均匀，则存储就均匀<br>hashcode： 10 1100 0011 1100 1001<br>length-1： 00 0000 0000 0000 1111<br>index:    00 0000 0000 0000 1001  结果就是1001，跟元素的低位相等</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>转换成红黑树，除了链表长度&gt;=8，还要求整个容量&gt;=64,否则也只是扩容，进行resize</li><li>长度&gt;=8转成红黑树，长度&lt;=6又转换成链表，为什么不是7，原因是因为有些时候，会出现频繁的插入、删除，导致整个值在8左右徘徊，进而触发频繁的链表和树的转换，用7这样一个过渡，防止频繁的转换</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBASE命令</title>
      <link href="/2019/11/14/HBASE%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/14/HBASE%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li>客户端连接    hbase client</li><li>显示表字段    describe tablename</li><li>获取数据    get ‘tablename’,’rowkey’</li></ul>]]></content>
      
      
      <categories>
          
          <category> 命令大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String考题</title>
      <link href="/2019/11/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/"/>
      <url>/2019/11/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>1、String.intern()方法的作用</strong><br><strong>答</strong>：intern是个native方法，首先理解一个概念，<br>String s1 = new String(“a”);//s1指向的是堆中的一个String对象<br>String s2 = “a”;//s2指向的是常量池中的常量的地址<br>JDK1.6 在常量池中创建与String内容相同的字符串，返回的是常量池中这个字符串的地址 有两个”a”,一个在常量池，一个在堆内存<br>JDK1.7 不会在常量池创建字符串，只是在常量池中记录heap中首次出现的实例的引用，并返回该引用，只有一个”a”<br>    - String s = “a”; 在常量池上创建常量<br>    - String s = new String(“a”); 只在堆中创建对象a<br>    - String s = new String(“a”);s.intern();在堆中创建对象a，并在常量池中保存对象a的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> String s1 = new String(&quot;aaabb&quot;);//①</span><br><span class="line"> String s1 = new String(&quot;aaa&quot;) + new String(&quot;bb&quot;);//②</span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = &quot;aaabb&quot;;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s2 == s3);</span><br><span class="line">System.out.println(s3 == s1);</span><br></pre></td></tr></table></figure><p>采用①创建对象，结果是 false，true，false<br>采用②创建对象，结果是 true,true,true 加号会默认用StringBuilder去append</p><p><strong>2、StringBuilder的append是如何实现的</strong><br><strong>答</strong>：底层是通过Arrays.copyOf -&gt; System.arraycopy实现的，字符串拼接，实际也是转成append，最后toString()返回的</p>]]></content>
      
      
      <categories>
          
          <category> 面试大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融风控知识</title>
      <link href="/2019/11/13/%E9%87%91%E8%9E%8D%E9%A3%8E%E6%8E%A7%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/13/%E9%87%91%E8%9E%8D%E9%A3%8E%E6%8E%A7%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="风控的定义"><a href="#风控的定义" class="headerlink" title="风控的定义"></a>风控的定义</h3><ul><li>风险管理：是指如何在项目或企业中在一定的风险环境中，将风险减至最低的过程，基本程序：风险识别、风险估测、风险评价、风险控制和风险管理效果评价等</li><li>风险控制：是指风险管理者采取各种措施或者方法，消灭或减少风险事件发生的可能性，或者减少风险事件发生时的造成的损失</li></ul><h3 id="风控场景"><a href="#风控场景" class="headerlink" title="风控场景"></a>风控场景</h3><p>贷前，贷中，贷后监控，平台资金安全，平台系统安全，用户资金安全，用户账户安全，推广运营活动等环节，还用于还款能力、还款意愿的判断，反欺诈反作弊，防范团伙作案，防止外部对内部系统的攻击等</p><ul><li>用户账户安全 建立注册手机号黑名单，实名认证，人脸识别</li><li>短信验证码 要防止恶意刷验证码，设置图形验证码，延迟设备号+ip发送短信次数，ip地址和手机号地里位置映射，短信预警每日发送限额</li><li>登录行为 是否异地登录，touchid图形验证登录方式安全性高，常用设备登录，连续密码错误</li><li>投资风险，针对高收益的标的，会有团队进行秒标，需要增加多层验证，防止机器人投标</li><li>推广运营风险 建立内部黑名单，推广效果监控，电话回访，建立自动预警机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 业务知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GC知识</title>
      <link href="/2019/11/12/GC%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/12/GC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>GC主要是针对堆空间</strong></p><h4 id="主要名词"><a href="#主要名词" class="headerlink" title="主要名词"></a><strong>主要名词</strong></h4><ul><li>引用计数法 每个对象都有一个引用计数器，每次被引用就+1，引用失效就-1，对于计数器为0的就是垃圾，但是这种计数器无法解决互相引用问题，比如A.instance=B;B.instance=A;</li><li>可达性分析/根搜索算法 通过一系列称为“GC Roots”的对象作为起点，向下搜索，搜索走过的路径称为“引用链”，当一个对象到“GC Roots”没有任何的引用链相连时，证明此对象不可达</li></ul><p><strong>可以作为GC Roots的对象：</strong></p><ul><li>虚拟机栈中引用的对象 –正常创建的对象</li><li>方法区中静态属性引用的对象 –类中定义了全局静态的对象，使用了static关键字</li><li>方法区中常量引用的对象 –常量引用，使用了static final关键字</li><li>本地方法栈中native引用的对象</li></ul><h4 id="什么时候触发minorGC-YGC"><a href="#什么时候触发minorGC-YGC" class="headerlink" title="什么时候触发minorGC(YGC)"></a><strong>什么时候触发minorGC(YGC)</strong></h4><p>前提条件：在老年代的空闲空间，足够容纳新生代晋升的对象总空间时</p><ul><li>新生代已满，无法创建对象</li></ul><h4 id="什么时候触发fullGC"><a href="#什么时候触发fullGC" class="headerlink" title="什么时候触发fullGC"></a><strong>什么时候触发fullGC</strong></h4><ul><li>老年代无法容纳新创建的大对象</li><li>YGC出现promotion failure，老年代内存不足以容纳，从survive区拷贝到老年代的对象，</li><li>持久代内存不足 比如通过动态代理生成了很多代理类</li><li>显式System.gc()</li></ul><h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><strong>finalize方法</strong></h4><p>可达性分析完的对象，并不会马上被回收，而是有缓刑</p><ul><li>第一次标记，判断对象是否需要执行finalize方法，当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，直接回收</li><li>第二次标记，如果上面一步判断为有必要执行finalize方法，则被加入到一个F-Queue中，并在稍后有虚拟机自动创建、低优先级的Finalize线程去执行回收</li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a><strong>回收算法</strong></h4><ul><li>标记清除算法<br>第一步根据根搜索算法，将活跃对象标记出来<br>第二步扫描所有对象，将未标记的对象清除<br>缺点是：容易产生很多内存碎片</li><li>复制算法<br>把内存分成两块，一块存储，一块空着，GC的时候，将存活的对象拷贝到空的内存，最后将原来的那一半全清理掉<br>缺点是：利用率只有一半</li><li>标记整理算法<br>跟标记清除算法一样，只是多了一步，在标记清除执行完后，再将存活对象向一端移动，减少内存碎片</li><li>分代收集<br>根据不同的代，采用不同的算法<br>年轻代：使用复制算法，因为年轻代的对象较多，每次gc都有很多对象被回收，存活的对象较少，采用复制算法最合适<br>老年代：以标记整理算法为主，老年代的对象存活时间长，需要删除的对象比较少</li></ul><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a><strong>垃圾回收器</strong></h4><ul><li>新生代收集器 Serial、ParNew、Parallel Scavenge</li><li>老年代收集器 CMS、Serial Old、Parallel Old </li><li>整堆收集器 G1</li></ul><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a><strong>CMS</strong></h4><p><strong>以获取最回收停顿时间为目标的收集器，基于并发“标记清除”算法实现</strong></p><ul><li>初始标记：独占CPU(STW)，仅标记GCRoots能直接关联的对象</li><li>并发标记：与用户线程并行，标记所有可达对象</li><li>重新标记：独占CPU(STW)，对并发标记阶段用户产生的垃圾对象进行标记修正</li><li>并发清理：与用户线程并行，清理垃圾</li></ul><p><strong>缺点</strong></p><ul><li>对CPU敏感：在并发标记阶段，虽然与用户线程并行，但是会占用一部分CPU，导致用户线程变慢</li><li>无法处理浮动垃圾：在并发清理阶段，用户线程还是会产生垃圾，这部分垃圾只能在下一次回收时才能回收</li><li>产生内存碎片：由于使用标记清除算法，会导致一部分内存碎片，可能导致老年代剩余空间很多，但是无法找到连续的空间，来分配给某个大对象，不得不触发一次fullgc，虽然提供了整理开关，但是整理是不能并发的，空间碎片没有了，等待时间会变长</li></ul><p><strong>出现FullGC原因</strong></p><ul><li>碎片过多，无法给对象分配连续空间</li><li>并发过程中，jvm觉得并发过程结束之前，堆就会满，提前触发FullGC</li></ul><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a><strong>G1</strong></h4><p><strong>是一款面向服务端应用的垃圾回收器，管理整个堆内存，将堆内存划分成一个个Region，通过RememberedSet维护Region和新生代老年代的关系</strong><br><strong>特点</strong></p><ul><li>并行于并发：能充分利用多核CPU的硬件优势，来缩短STW的时间</li><li>分代收集：G1自己管理新生代和老年代，然后采用不桶的方式收集垃圾</li><li>空间整合：G1从整体上看是标记整理算法，从局部（两个region）上看，是复制算法，整个运行期间不会产生碎片</li><li>可预测停顿：可以让使用者明确指定在一个长度为M毫秒时间片上，消耗在GC上的时间不超过N毫秒</li></ul><p><strong>过程</strong></p><ul><li>初始标记：STW，标记与GCRoots直接联系的对象</li><li>并发标记：与用户线程并行，标记所有的可达对象</li><li>最终标记：STW，将标记记录存储到remember set log中，然后合并到remember set，通过remember set来管理对象引用</li><li>筛选回收：STW，根据回收价值和成本进行排序，根据用户所期望的GC时间进行回收</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常见错误</title>
      <link href="/2019/11/12/JVM%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>/2019/11/12/JVM%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h4><p>代码中出现无限递归或者代码调用层数很深，就是jvm栈溢出</p><h4 id="OOM：GC-overhead-limit-exceeded"><a href="#OOM：GC-overhead-limit-exceeded" class="headerlink" title="OOM：GC overhead limit exceeded"></a>OOM：GC overhead limit exceeded</h4><p>超过98%的时间用来做GC并且回收了不到2%的堆内存，就会报这个错误</p><h4 id="OOM：Java-heap-space"><a href="#OOM：Java-heap-space" class="headerlink" title="OOM：Java heap space"></a>OOM：Java heap space</h4><p>如果内存只有1M，生成&gt;1M的数组，直接报错内存不够<br>实现方式 生成很多对象，且保持可达，直到堆内存不足<br>相关配置 -Xms512m -Xmx512m</p><h4 id="OOM：PermGen-space-或-Metaspace"><a href="#OOM：PermGen-space-或-Metaspace" class="headerlink" title="OOM：PermGen space 或 Metaspace"></a>OOM：PermGen space 或 Metaspace</h4><p>永久代内存不够，主要是方法区，无限递归就可以触发此异常<br>jdk1.8以下相关配置 -XX:PermSize=256M -XX:MaxPermSize=1024M<br>jdk1.8以上相关配置 -XX:MaxMetaspaceSize=128m<br>实现方式：永久代存储的大部分是编译后的代码，可以通过cglib代理，产生大量的动态代码</p><h4 id="栈溢出和栈内存溢出"><a href="#栈溢出和栈内存溢出" class="headerlink" title="栈溢出和栈内存溢出"></a>栈溢出和栈内存溢出</h4><p>栈溢出：代码调用层数过深，如无限递归<br>栈内存溢出：每一个线程对应一个栈，线程太多，导致无法分配内存</p>]]></content>
      
      
      <categories>
          
          <category> JVM专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper工作原理</title>
      <link href="/2019/11/12/Zookeeper%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/12/Zookeeper%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><table><thead><tr><th>角色</th><th></th><th>描述</th></tr></thead><tbody><tr><td>领导者(Leader)</td><td></td><td>负责投票的发起和决议，更新系统状态</td></tr><tr><td>学习者(Learner)</td><td>跟随者(Follower)</td><td>用于接收客户端请求，并返回结果，参与选主投票</td></tr><tr><td></td><td>观察者(Observber)</td><td>可以接收客户端请求，<font color=#ff0000>将写操作转发给Leader，不参与选主投票，只同步leader状态</font>，主要是为了扩展系统，提高读取速度</td></tr><tr><td>客户端(Client)</td><td></td><td>请求发起方</td></tr></tbody></table><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a><strong>设计目的</strong></h3><p>1、最终一致性：client不管连哪个server，数据视图是一样的<br>2、可靠性：消息被一台server接受，那将被集群中所有的server接受<br>3、实时性：保证客户端在一个时间范围内，获取到服务器更新活失效信息，但是不保证两个客户端能同时得到刚更新的信息，需要自己调用sync()接口<br>4、等待无关：慢的client或者失效client不会干预到快的client请求<br>5、原子性：更新只能成功或者失败，不存在中间状态<br>6、顺序性：包括全局有序和偏序：全局有序是指如果一台服务器上消息a在消息b前发布，那在集群中其他server消息也是a在b之前发布，偏序是指一个消息b在消息a后被同一个发送者发布，a必排在b之前</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><ul><li>原子广播：核心机制，保证各个server之间消息同步，由Zab协议实现</li><li>Zab协议：恢复模式(选主)和广播模式(同步)，当服务启动或leader崩溃，集群进入恢复模式，当leader被选举出来，且大多数server完成了和leader的同步，恢复模式结束</li><li>事务一致性：递增的事务id(zxid)来标识事务，zxid是一个64位的数字，高32位epoch标识leader的关系是否改变，每次一个leader选举出来，都会有一个新的epoch，标识属于那个leader的统治时期，低32位用于递增计数</li><li>每个server在工作中有三种状态：<ul><li>looking：当前server不知道leader是谁，正在搜寻</li><li>leading：当前server即为选出来的leader</li><li>following：leader已经选举出来，当前server与之同步</li></ul></li></ul><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a><strong>选举过程</strong></h3><ul><li>每个server会发出一个投票，第一次都是投自己，投票信息：myid+zxid+epoch</li><li>收集其他server的投票</li><li>处理投票并重新投票。处理逻辑：<ul><li>比较epoch，选值大的，表明该节点的朝代新</li><li>比较zxid，选值大的，表明该节点的数据新</li><li>比较myid，选值大的，表明该节点是最新加入的</li></ul></li><li>统计投票，只要超过半数的server接收到同样的投票结果，就可以确定leader，如果没有，继续发起选举，知道成功选出leader</li><li>同步leader信息，改变server状态</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul><li>过半数原则：是&gt;half，不是&gt;=half</li><li>选主期间整个集群不可用，所以有可能出现多轮选举导致长时间不可用</li><li>过半数是过整个集群的半数，不是还存活server的半数，如：集群3台server，过半数是&gt;1.5，假如现在有台server挂了，那过半数还是&gt;1.5，并不是现有存活server(2/2=1)</li><li><strong>集群数量最好是奇数</strong><ul><li>防止脑裂：脑裂是由于网络等原因，导致集群被分割成了两个小集群，如         3台脑裂后，分为1台区和2台区，2台区仍是可以选主的；<br>4台脑裂后，分为1+3，或者 2+2，如果是2+2的情况，不能满足选主&gt;2</li><li>容错能力相同：4台集群(可用必须&gt;4/2，只有3和4)，即只允许挂一台机器，3台集群(可用必须&gt;3/2,只有2和3)，也是只允许挂一台机器，所以容错能力一样，3台更节省资源</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper基础知识</title>
      <link href="/2019/11/12/Zookeeper%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/12/Zookeeper%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>Zookeeper是分布式协作框架，主要是为了分布式系统数据管理，如：统一命名服务，状态同步服务，集群管理，分布式应用配置项管理等<br>Zookeeper=文件系统+通知机制</strong></p><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a><strong>节点类型</strong></h4><p>zk维护了一个类似文件系统的数据结构，每一个节点是znode，也可以用来存储数据，有四种类型的zbode，区别在于客户端和服务端断开以后，临时节点是否会被删除，持久化节点不会，有序节点会在指定节点名称后加一长串数字，用来标识顺序</p><ul><li>持久化节点</li><li>持久化有序节点</li><li>临时节点</li><li>临时有序节点  </li></ul><p><strong>临时节点只能是子节点，把临时节点作为主节点添加子节点，会报NoChildrenForEphemerals错误</strong></p><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a><strong>状态信息</strong></h4><blockquote><p>[zk: localhost:2181(CONNECTED) 5] get /zk_test<br>test_data<br>cZxid = 0x4000092ec<br>12<br>ctime = Thu Mar 07 10:34:59 CST 2019<br>mZxid = 0x4000092ec<br>mtime = Thu Mar 07 10:34:59 CST 2019<br>pZxid = 0x4000092ec<br>cversion = 0<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 12<br>numChildren = 0</p></blockquote><table><thead><tr><th>状态属性</th><th>说明</th></tr></thead><tbody><tr><td>cZxid</td><td>数据节点创建时的事务ID</td></tr><tr><td>ctime</td><td>数据节点创建时的时间</td></tr><tr><td>mZxid</td><td>数据节点最后一次更新时的事务ID</td></tr><tr><td>mtime</td><td>数据节点最后一次更新时的时间</td></tr><tr><td>pZxid</td><td>数据节点的子节点列表最后一次被修改（是子节点列表变更，而不是子节点内容变更）时的事务ID</td></tr><tr><td>cversion</td><td>子节点的版本号</td></tr><tr><td>dataVersion</td><td>数据节点的版本号</td></tr><tr><td>aclVersion</td><td>数据节点的ACL版本号</td></tr><tr><td>ephemeralOwner</td><td>如果节点是临时节点，则表示创建该节点的会话的SessionID；如果节点是持久节点，则该属性值为0</td></tr><tr><td>dataLength</td><td>数据内容的长度</td></tr><tr><td>numChildren</td><td>数据节点当前的子节点个数</td></tr></tbody></table><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a><strong>版本</strong></h4><p>zk为数据节点引入了版本，每个数据节点都有三个版本</p><table><thead><tr><th>版本类型</th><th>说明</th></tr></thead><tbody><tr><td>version</td><td>当前数据节点内容的版本号</td></tr><tr><td>cversion</td><td>当前数据节点子节点的版本号</td></tr><tr><td>aversion</td><td>当前数据节点ACL变更版本号</td></tr></tbody></table><p><strong>这些版本都是一个从0开始累加的数字，代表了被更新的次数</strong></p><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a><strong>通知机制</strong></h4><p>客户端注册监听它关心的节点目录，当目录节点发生变化(数据改变，被删除，子目录节点增加删除)时，zk会通知客户端</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul><li>命名服务 每个path都是唯一的，通过path就能互相发现</li><li>配置管理 当做配置中心，把配置存储在这，当配置变化时，通知客户端</li><li>集群管理 机器的接入退出，选举master，采用临时节点做provider，选主可以用临时有序，编号小的作为master</li><li>分布式锁<ul><li>独占锁：都去创建节点/XXX，谁创建成功就持有锁，用完删除</li><li>控制时序：先创建/parent，然后都在这个节点下面去创建新节点，序号小的优先</li></ul></li><li>队列管理 <ul><li>同步队列 要所有的都到齐了，才继续进行</li><li>FIFO队列 创建临时有序节点，入列有编号，按编号出列</li></ul></li></ul><h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a><strong>数据复制</strong></h4><ul><li>容错 一个节点down，其他节点接管工作</li><li>提高系统扩展能力 把负载分布到多节点上，或者增加节点，提高程序的抗压能力</li><li>提高性能 客户端就近访问节点</li><li>一般数据复制方式<ul><li>写主WriteMater</li><li>写任意WriteAny  </li></ul></li></ul><p><strong>zk使用的是写任意，修改任意一个节点的数据，会同步给其他节点，这个就涉及到如何保证数据一致性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo知识</title>
      <link href="/2019/11/11/Dubbo%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/11/11/Dubbo%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>dubbo是一个分布式服务框架，RPC框架，SOA框架，采用TCP协议通信，</p><ul><li>作为RPC：支持各种传输协议,如：dubbo,hession,json,fastjson,底层采用mina，netty tcp长连接进行传输</li><li>作为SOA：具有服务治理功能，用zookeeper做注册中心，实现服务注册和服务发现</li></ul><p>除了提供服务以外，还实现了软负载，还提供了监控中心和注册中心（可选），在没有注册中心的情况下，是Consumer和Provider是可以直连的</p><p><img src="/images/pasted-1.png" alt="原理图"></p><ul><li>服务提供者启动，注册到注册中心</li><li>消费者会订阅服务，如果没订阅到会不停重试</li><li>有新的生产者提供服务时，注册中心会通知消费者</li><li>消费者通过RPC调用到远端服务</li><li>Monitor是异步监听，Provider和Consumer会将消息存储在本地磁盘，平均每分钟会发送一次信息</li></ul><h2 id="初始化细节"><a href="#初始化细节" class="headerlink" title="初始化细节"></a>初始化细节</h2><ul><li>解析服务<ul><li>基于dubbo.jar中的META_INF/spring.handlers配置，spring在遇到dubbo的命名空间时，会回调DubboNamespaceHandler类</li><li>所有的dubbo标签，都统一用DubboBeanDefinitionParser进行解析，基于一对一属性映射，将XML标签解析为Bean对象</li></ul></li><li>暴露服务<ul><li>只暴露服务端口，用在没有注册中心的情况下，dubbo://service-host/com.xxx.TxxService?version=1.0.0</li><li>向注册中心暴露服务，将ip和端口一起暴露给注册中心，基于扩展点的Adaptive机制，通过URL的“register://”协议头区别<ul><li>registry://registry-host/com.alibaba.dubbo.registry.RegistryService?export=URL.encode(“dubbo://service-host/com.xxx.TxxService?version=1.0.0”)</li></ul></li><li>调用RegisterProtocol的export方法，将export参数中的提供者URL先注册到注册中心，再重新传给protocol扩展点进行暴露，<ul><li>dubbo://service-host/com.xxx.TxxService?version=1.0.0</li></ul></li></ul></li><li>引用服务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广告行业</title>
      <link href="/2019/11/11/%E5%B9%BF%E5%91%8A%E8%A1%8C%E4%B8%9A/"/>
      <url>/2019/11/11/%E5%B9%BF%E5%91%8A%E8%A1%8C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CPM（Cost-per-mille），每千次展现收费"><a href="#1-CPM（Cost-per-mille），每千次展现收费" class="headerlink" title="1.CPM（Cost per mille），每千次展现收费"></a><strong>1.CPM（Cost per mille），每千次展现收费</strong></h3><p>这是一种最为常见的广告模式，也是很多网站流量变现的一种途径，这种广告不管计算点击，或者什么注册下载之类的转化，只要这个广告在网站上被正常的展现给一千个人看到即可。是流量大站或者一些做站群等变现的最有效的方式，这也就是说流量就是钱。</p><h3 id="2-CPC（Cost-per-click），每次点击收费"><a href="#2-CPC（Cost-per-click），每次点击收费" class="headerlink" title="2.CPC（Cost per click），每次点击收费"></a><strong>2.CPC（Cost per click），每次点击收费</strong></h3><p>CPC 就非常容易理解，就是不论你这个广告被多少人看见，只要没有产生点击就不会产生广告费用，对于广告主来说选择 CPC 模式可以有助于提升转化和降低费用，前面子凡谈及 OCPC 也就有所简单的分享，并且广告平台一般还可以限定一个 IP 在 24 小时内只能点击一次，其它的重复点击被视为无效，从而降低广告主的预算消耗。</p><h3 id="3-CPA（Cost-per-action），每次动作收费"><a href="#3-CPA（Cost-per-action），每次动作收费" class="headerlink" title="3. CPA（Cost per action），每次动作收费"></a><strong>3. CPA（Cost per action），每次动作收费</strong></h3><p>顾名思义就是按照完成一个指定的标准或者行为动作来进行收费的广告模式，而对这个动作行为就可以是注册、咨询、交易、下载、留言等等的数量进行计费。不过这种模式在充分考虑广告主利益的同时却忽略了网站主的利益，遭到了越来越多的网站主的抵制。</p><h3 id="4-CPS（Cost-per-sale），每次成功交易收费"><a href="#4-CPS（Cost-per-sale），每次成功交易收费" class="headerlink" title="4. CPS（Cost per sale），每次成功交易收费"></a><strong>4. CPS（Cost per sale），每次成功交易收费</strong></h3><p>这种方式就更为苛刻了，同时其价格也更高，是按照用户点击广告后最终购买或者消费的数量金额的一定比例进行分成，如果用户为完成最终的支付，都表示无效。</p><h3 id="5-CPL（Cost-per-lead-，每条数据收费"><a href="#5-CPL（Cost-per-lead-，每条数据收费" class="headerlink" title="5. CPL（Cost per lead)，每条数据收费"></a><strong>5. CPL（Cost per lead)，每条数据收费</strong></h3><p>其实就是以收集潜在用户的名单来收费的一种广告模式，按照广告点击引导用户到达服务商指定网页的客户数量计费，限定一个 IP 在 24 小时内只能点击一次。 即每次通过特定链接，注册成功后付费的一个常见广告模式，这是我们通常称谓的引导注册，被一些游戏或者 APP 应用推广大量采用。</p><h3 id="6-CPR（Cost-per-response），每次回应收费"><a href="#6-CPR（Cost-per-response），每次回应收费" class="headerlink" title="6. CPR（Cost per response），每次回应收费"></a><strong>6. CPR（Cost per response），每次回应收费</strong></h3><p>按照用户的回应数量计费，网民在正确回答广告主设定的问题或者拨打了网上提供的直播电话之后才被算作一次有效回应，且限定同一个 IP 在 24 小时内不能重复回答同一广告提出的问题。广告主为规避广告费用风险，只有在网络用户点击广告并进行在线交易后，才按销售笔数付给广告站点费用。</p>]]></content>
      
      
      <categories>
          
          <category> 业务知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA内存</title>
      <link href="/2019/11/10/JAVA%E5%86%85%E5%AD%98/"/>
      <url>/2019/11/10/JAVA%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU缓存结构"><a href="#CPU缓存结构" class="headerlink" title="CPU缓存结构"></a>CPU缓存结构</h3><p>cpu缓存是介于CPU与内存之间的数据临时交换器，为了解决CPU处理速度和内存读写速度不匹配的矛盾<br><img src="/images/pasted-0.png" alt="CPU缓存"><br>L1,L2,L3三级缓存目前都是集成在CPU中，速度L1&gt;L2&gt;L3,容量L1&lt;L2&lt;L3，CPU查找数据优先级L1&gt;L2&gt;L3&gt;内存,每个缓存都是为上一级缓存做缓冲</p><ul><li>L1i一级指令缓存</li><li>L1d一级数据缓存<br>参考链接：<a href="http://baijiahao.baidu.com/s?id=1598811284058671259" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1598811284058671259</a></li></ul><h4 id="运行时内存分布"><a href="#运行时内存分布" class="headerlink" title="运行时内存分布"></a><strong>运行时内存分布</strong></h4><ul><li>JVM栈 线程运行时执行过程，每个方法执行都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用到结束，对应着入栈到出栈<ul><li>局部变量表 存放基本数据类型、对象引用和returnAddress(下一跳字节码指令地址)</li><li>操作数栈 jvm底层字节码指令集是基于栈类型，所有的操作码都是对操作数栈上的数据进行操作</li><li>动态链接 Class字节码常持有大量的符号引用，在运行期才转变成直接引用(也就是指向数据)</li><li>方法出口 本方法执行后的下一步指令地址，方法正常退出，调用者的PC计数器</li></ul></li><li>本地方法栈 用来执行native方法，sun hotspot将jvm栈和本地方法栈合二为一</li><li>程序计数器 用来记录当前线程指令执行的行号(指令偏移地址)，唯一一个没有OOM的区域，比如CPU的执行是按时间片交替执行，CPU先执行线程A一段代码，再执行线程B一段代码，程序计数器记录的就是AB线程当前执行的指令偏移地址</li></ul><p><strong>上面三个是线程私有的，下面是公有的</strong></p><ul><li>堆 存储对象 1.8以上加入常量池</li><li>方法区(&lt;1.8) 元数据(&gt;1.8)，存储已被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等</li></ul><h4 id="堆的组成"><a href="#堆的组成" class="headerlink" title="堆的组成"></a><strong>堆的组成</strong></h4><ul><li>新生代young  （8：1：1） minorGC<ul><li>eden 新建的对象都存在这，除非大对象存不下，才会直接进old</li><li>s0，s1 用来互相拷贝，实现年龄增长，默认是15次GC后就会进入老年代</li></ul></li><li>老年代old FullGC 存储熬过minorGC的对象</li><li>1.8之前 持久代perm 存储方法</li><li>1.8之后 元数据meta space</li><li>老年代:新生代 = 2:1<br><img src="/images/pasted-36.png" alt="内存组成"><br><img src="/images/pasted-6.png" alt="内存图"></li></ul><h4 id="担保机制"><a href="#担保机制" class="headerlink" title="担保机制"></a><strong>担保机制</strong></h4><p>当新生代无法为新对象分配内存的时候，把原来新生代对象转移到老年代，如果新对象超过了新生代的最大内存，直接进入老年代</p><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a><strong>内存泄露</strong></h4><ul><li>长生命周期的对象持有短生命周期的引用，比如：对象A有个方法，每次调用都会new一个别的对象B，只要A不被回收，B就一直在，最好是B作为局部变量</li><li>集合泄露，比如HashMap，ArrayList被声明为static对象时，他们的生命周期跟应用程序一样长</li></ul><p><strong>为什么要有survive区？为什么是8:1:1？</strong><br>答：jvm在设计之初，希望对象在新生代，用完之后就直接被回收，但是有些对象会存活很长时间，因为老年代的fullgc很费时间，所以为了尽量避免对象进入老年代，采用达到一定年龄，才能进入老年代，通过survive区交替来处理实现年龄的增长</p><p><strong>为什么1.8取消永久代，用元数据替代</strong><br>答：①官宣就是移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代<br>②使用中也有可能动态代理生成的类过多，导致PermGen</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/2019/11/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/11/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="JUC包-java-util-concurrent"><a href="#JUC包-java-util-concurrent" class="headerlink" title="JUC包 java.util.concurrent"></a>JUC包 java.util.concurrent</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><strong>CountDownLatch</strong></h4><ul><li>当指定数量的线程执行完后，当前线程才进行后面的操作</li><li>不可复用，用完即止</li><li>主要方法是await()和countDown()，可设置超时时间await(timeout,TimeUnit)，超时就不会继续等待，直接进行后面的操作，</li><li>使用方法：线程A需要等待BCD执行完，才能继续，A.await(),BCD执行完调用countDown()</li></ul><p><strong>设置一个计数器，await实现暂时将线程加入阻塞队列，countDown用来减少计数器，当计数器为0时，阻塞队列的线程被唤醒，thread的join方法可以使主线程等待，但是没办法使用到线程池中</strong><br><strong>底层原理：以AQS框架的state来作为计数器，CAS去实现计数器原子减少，通过AQS的队列来作为阻塞队列，当计数器为0时，逐个唤醒等待队列</strong></p><h4 id="CyclicBarrier-内存屏障"><a href="#CyclicBarrier-内存屏障" class="headerlink" title="CyclicBarrier 内存屏障"></a><strong>CyclicBarrier 内存屏障</strong></h4><ul><li>当指定数量的线程执行完后，再一起接着执行</li><li>可复用，一批一批的，类似有扇门，当门口等待数达到阈值，才开门，放这批进去，然后关门等下一批</li><li>可用于限流</li><li>主要方法是await()，也支持超时设置，超时就自动进行后面操作</li></ul><p><strong>底层原理：主要是通过 ReentrantLock 和 AQS中ConditionObject 共同实现，</strong></p><h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a><strong>Semaphore 信号量</strong></h4><ul><li>授权许可证，常用来限制获取资源的线程数，可用来做限流</li><li>主要方法有acquire()和release()</li></ul><p><strong>底层原理：以AQS框架的state来作为可用许可数量，获取许可时，state减去相应的许可数量再替换原值，没有许可时，当前线程阻塞进入AQS等待队列，当有线程释放锁时，会触发等待队列唤醒</strong></p><h4 id="ConcurrentHashMap-并发map"><a href="#ConcurrentHashMap-并发map" class="headerlink" title="ConcurrentHashMap  并发map"></a><strong>ConcurrentHashMap  并发map</strong></h4><ul><li>根据key的hash值来进行分桶，形成一个桶数组，每个桶里面有个链表，存储kv对象</li><li>分段锁机制，每个桶有一把锁，当有并发修改时，同一个桶的才会竞争锁，不同桶获取的是不同的锁</li><li>key和value都不允许为null，key为null没办法确定哪个桶</li></ul><p><strong>jdk1.8+</strong></p><ul><li>取消segment字段，直接采用CAS+Synchronized来保证并发更新的安全，transient volatile HashEntry&lt;K,V&gt; table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率；transient修饰的变量其内容在序列化后无法获得访问</li><li>引入红黑树，当链表长度达到8时，链表转换为红黑树</li></ul><h4 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock 可重入锁"></a><strong>ReentrantLock 可重入锁</strong></h4><ul><li>基于AQS：volatite int state</li><li>获取锁：尝试对state进行CAS(0,1)操作，尝试几次(跟jvm参数设置有关)失败后就挂起线程，进入等待队列</li><li>释放锁：对state进行CAS(1,0)操作，然后去唤醒等待队列中的一个线程</li></ul><h4 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a><strong>BlockingQueue 阻塞队列</strong></h4><p>基于数组的有界阻塞队列，通过ReentrantLock和两个Condition条件对象来实现阻塞</p><ul><li>add 将e加入队列，如果可以容纳，返回true，不可以报异常</li><li>offer 将e加入队列，如果可以容纳，返回true，不可以返回false</li><li>put 将e加入队列，如果没有空间，会一直阻塞在那直到有空间</li><li>poll(time) 取走队列里排在首位的对象，若不能立即取出，等待time时间后，取不到返回null</li><li>take 取走队列首位的对象，若队列为空，阻塞到直到队列有数据加入为止</li><li>remainingCapacity()：剩余可用的大小。等于初始容量减去当前的 size</li></ul><p><strong>使用场景</strong></p><ul><li>先进先出队列FIFO</li><li>有界队列 指定初始化容量，如果已满，就一直阻塞，如果为空，取出阻塞</li><li>要求队列不支持空元素的</li></ul><p><strong>ArrayBlockingQueue和LinkedBlockingQueue区别</strong></p><ul><li>array是插入和取出共用一把锁，linked是插入和取出是独立的锁</li><li>array是有界初始化必须指定大小，linked是有无界可指定也可不指定(Integer.MAX_VALUE)，如果linked添加速度大于移除速度，有可能会造成内存溢出</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2019/11/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/11/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a><strong>线程生命周期</strong></h4><ul><li>新建New</li><li>就绪Runnable</li><li>运行Running</li><li>阻塞Blocking</li><li>死亡Dead</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><ul><li>提高效率，创建一个线程很花时间，直接拿来用更快</li><li>方便管理，通过线程池，可有效避免无限制的创建线程导致系统崩溃</li></ul><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h4><ul><li>线程池管理器(ThreadPoolManager),创建并管理线程池</li><li>工作线程(WorkerThread)，线程池中线程</li><li>任务接口(Task)，每个任务必须实现的接口，以供工作线程调度任务的执行</li><li>任务队列，用于存放没有处理的任务，提供一种缓冲机制</li></ul><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a><strong>主要内容</strong></h4><ul><li>核心线程数 corePoolSize<ul><li>主要工作者，类似于正式员工，可以不初始化，也可以在线程池启动时一次性创建</li><li>当线程数量&lt;核心线程数，即使现在线程空闲，也会优先创建新线程去处理</li></ul></li><li>最大线程数 maxPoolSize<ul><li>线程池中允许存在的最大线程数量</li></ul></li><li>线程空闲时间 keepAliveTime<ul><li>非核心线程空闲时间阈值，超时线程会退出，直到线程数量=corePoolSize，如果设置了allowCoreThreadTimeOut，那核心线程数也会超时退出，直到0</li></ul></li><li>线程工厂 threadFactory<ul><li>ArrayBlockingQueue 基于数组的有界队列 </li><li>LinkedBlockingQueue 基于链表的无界队列 适用于FixedThreadPool与SingleThreadExcutor</li><li>SynchronousQueue 一个没有容量的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，适用于CachedThreadPool</li><li>PriorityBlockingQueue 具有优先权的阻塞队列</li></ul></li><li>拒绝策略 RejectedExecutionHandler 已经达到最大线程数，并且等待队列满的时候触发<pre><code>- AbortPolicy 直接丢弃，抛出异常- DiscardPolicy 直接丢弃，不报异常- DiscardOldestPolicy 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）- CallerRunsPolicy 由主线程执行(这种策略在线程激增时，大量线程交给主线程去执行，会导致系统hang住) - 自己实现</code></pre></li><li>ReentrantLock 线程池的主要状态锁，对线程池状态（比如线程池大小runState等）的改变都要使用这个锁</li></ul><h4 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a><strong>处理过程</strong></h4><p>当有请求过来时：</p><ul><li>如果 当前线程数&lt;核心线程数，则创建新线程去处理当前请求</li><li>如果 当前线程数=核心线程数&lt;最大线程数 &amp;&amp; 等待队列未满，则将请求放到等待队列中</li><li>如果 当前线程数=核心线程数&lt;最大线程数 &amp;&amp; 等待队列已满，则增加处理线程，去处理等待队列中请求</li><li>如果 当前线程数 = 最大线程数 &amp;&amp; 队列已满，则根据拒绝策略去处理当前请求</li></ul><h4 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a><strong>常见线程池</strong></h4><p><strong>推荐使用ThreadPoolExecutor自己构造线程池，更加明确线程池的运行规则，规避资源耗尽的风险</strong><br><strong>在Executors类中</strong></p><ul><li>SingleThreadPool：单线程池 用于顺序执行,LinkedBlockingQueue</li><li>FixedThreadPoool：固定线程数线程池 用于CPU密集型 LinkedBlockingQueue</li><li>CachedThreadPool：缓存线程池 当线程池长度不够处理，可以灵活回收线程，或者创建新线程来执行，默认maxpoolsize=Integer.MAX_VALUE，若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存 用于并发执行大量短期的小任务,SynchronousQueue</li><li>ScheduledThreadPool：计划线程池 默认maxpoolsize=Integer.MAX_VALUE，用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景,DelayedWorkQueue</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>参考：<a href="https://www.cnblogs.com/baizhanshi/p/5469948.html" target="_blank" rel="noopener">四种线程池</a></p><h4 id="线程池大小配置"><a href="#线程池大小配置" class="headerlink" title="线程池大小配置"></a><strong>线程池大小配置</strong></h4><ul><li>如果是CPU密集型，则线程池大小设置成N+1</li><li>如果是IO密集型，则线程池大小设置成2N+1；如果是线程等待时间越长，需要的线程越多  最佳线程数目=（线程等待时间与线程CPU时间之比 + 1）* CPU数目，比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32</li></ul><h4 id="为什么使用阻塞队列，而不是用普通队列"><a href="#为什么使用阻塞队列，而不是用普通队列" class="headerlink" title="为什么使用阻塞队列，而不是用普通队列"></a><strong>为什么使用阻塞队列，而不是用普通队列</strong></h4><p>答：主要是运用生产者消费者模型，使用阻塞队列时，线程拿不到数据就阻塞等待，当有消息时自动唤醒，如果用普通队列，还需要自己去实现同步策略和唤醒策略，这个实现其实等同于自己实现阻塞队列</p><h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a><strong>僵尸进程和孤儿进程</strong></h4><p>答：一个子进程执行exit后，并非马上消失，而是留下一个称为僵尸进程，其父进程设置为1，1是init进程，然后由init去处理这些僵尸进程</p><ul><li><p>存在原因：这个僵尸状态是为了方便父进程在以后某个时间获取相关信息，至少包括子进程id，状态和cpu时间等</p></li><li><p>危害：僵尸进程的pid还占据在进程列表中，内核栈无法被释放</p></li><li><p>孤儿进程–父进程先于子进程结束 子进程在终止之前，会变成孤儿线程，再交由进程id=1的进程去收养</p></li><li><p>僵尸进程–子进程先于父进程结束 内核会为每个终止子进程保留一定量的信息，父进程就可以通过调用wait函数来获取这些信息。如果父进程没有调用wait函数的话，则该资源就会一直被占用</p></li><li><p>查看僵尸进程：ps -ef | grep defunct | more</p></li><li><p>忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统信息</title>
      <link href="/2019/11/09/%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/11/09/%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<ul><li>文件大小及个数<br>ls -l|grep “^-“|wc -l</li><li>查看当前文件夹大小<br>du -sh</li><li>统计当前文件夹(目录)大小，并按文件大小排序<br>du -sh * | sort -n</li></ul><ul><li>查看linux版本<br>uname -a<br>cat /proc/version   操作系统版本<br>cat /etc/redhat-release  查具体版本</li><li>查看物理CPU个数<br>cat /proc/cpuinfo| grep “physical id”| sort| uniq| wc -l</li><li>查看每个物理CPU中core的个数(即核数)<br>cat /proc/cpuinfo| grep “cpu cores”| uniq</li><li>查看逻辑CPU的个数<br>cat /proc/cpuinfo| grep “processor”| wc -l</li><li>查看CPU信息（型号）<br>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</li></ul>]]></content>
      
      
      <categories>
          
          <category> 命令大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2018/11/09/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/11/09/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh key"></a><strong>ssh key</strong></h4><p>ssh-keygen -t rsa -C “XXX@XX”</p><h4 id="免密设置"><a href="#免密设置" class="headerlink" title="免密设置"></a><strong>免密设置</strong></h4><p>cat /root/.ssh/id_rsa.pub<br>vi /root/.ssh/authorized_keys<br>把公钥加进去</p><h4 id="git设置"><a href="#git设置" class="headerlink" title="git设置"></a><strong>git设置</strong></h4><p>cat ~/.gitconfig   查看默认账号配置<br>git config –global user.name “XXX”<br>git config –global user.email “XXXX@XX”</p><h4 id="npm操作"><a href="#npm操作" class="headerlink" title="npm操作"></a><strong>npm操作</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 查看版本</span><br><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line"># 升级</span><br><span class="line">$ sudo npm install npm -g</span><br><span class="line"></span><br><span class="line"># 安装模块</span><br><span class="line">$ npm install &lt;Module Name&gt;    #本地安装</span><br><span class="line"># 本地安装：安装到./node_modules(命令运行目录)</span><br><span class="line">$ npm install &lt;Module Name&gt; -g #全局安装</span><br><span class="line"># 全局安装：放在 /usr/local 下或者你 node 的安装目录。</span><br><span class="line"></span><br><span class="line"># 卸载模块</span><br><span class="line">$ npm uninstall &lt;Module Name&gt;</span><br><span class="line"></span><br><span class="line"># 更新模块</span><br><span class="line">$ npm update &lt;Module Name&gt;</span><br><span class="line"></span><br><span class="line"># 查看所有安装的模块</span><br><span class="line">$ npm ls     #所有本地模块</span><br><span class="line">$ npm ls -g  #所有全局模块</span><br><span class="line"></span><br><span class="line"># 搜索模块</span><br><span class="line">$ npm search &lt;Module Name&gt;</span><br></pre></td></tr></table></figure><h4 id="替换-n"><a href="#替换-n" class="headerlink" title="替换\n"></a><strong>替换\n</strong></h4><p>sed “s/\n//g” file<br>sed -i ‘s/\r$//‘  file</p><h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a><strong>拷贝文件</strong></h4><p>scp local_file remote_username@remote_ip:remote_folder</p><p>scp -r local_folder remote_username@remote_ip:remote_folder  </p><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a><strong>过滤</strong></h4><p>grep -n aaa bbb.txt<br>grep -n ‘13:29:|13:29:’ a.log<br>grep -A 10 -B 10  前10行 后10行<br>grep -n ‘aaa’ | grep ‘3375544’ a.log </p><p>grep ‘saveSignedFile fail contractNo’ a.log |tail -n 1<br>grep -A 10 -B 10  ‘111’  bbb.txt | tail -n 1   最后一条</p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a><strong>发送请求</strong></h4><p>curl -H “Content-Type: application/json”<br>    -X POST<br>    -d ‘{“user_id”: “123”, “coin”:100, “success”:1, “msg”:”OK!” }’<br>    “<a href="http://192.168.0.1:8001/test&quot;" target="_blank" rel="noopener">http://192.168.0.1:8001/test&quot;</a></p>]]></content>
      
      
      <categories>
          
          <category> 命令大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
